# ./src/types/casinoTypes.ts
export interface CasinoResult {
    multiplier: number;
    emoji: string;
    description: string;
}

export interface CasinoMultiplier {
    chance: number;
    value: number;
    emoji: string;
    description: string;
}

# ./src/types/giftTypes.ts
export interface GiftReward {
    type: 'nothing' | 'currency';
    name: string;
    emoji: string;
    rarity?: 'common' | 'uncommon' | 'rare' | 'legendary';
    amount?: number;
}

export interface GiftType {
    chance: number;
    reward: GiftReward;
}

export const GIFT_TYPES: GiftType[] = [
    {
        chance: 0.40, 
        reward: {
            type: 'nothing',
            name: '–ü—É—Å—Ç–æ–π –ø–æ–¥–∞—Ä–æ–∫',
            emoji: 'üì¶'
        }
    },
    {
        chance: 0.40, 
        reward: {
            type: 'currency',
            name: '–ù–µ–º–Ω–æ–≥–æ –º–æ–Ω–µ—Ç',
            emoji: 'üí∞',
            rarity: 'common'
        }
    },
    {
        chance: 0.15, 
        reward: {
            type: 'currency',
            name: '–ú–µ—à–æ—á–µ–∫ —Å –º–æ–Ω–µ—Ç–∞–º–∏',
            emoji: 'üí∏',
            rarity: 'uncommon'
        }
    },
    {
        chance: 0.04, 
        reward: {
            type: 'currency',
            name: '–°—É–Ω–¥—É–∫ —Å –∑–æ–ª–æ—Ç–æ–º',
            emoji: 'üí∂',
            rarity: 'rare'
        }
    },
    {
        chance: 0.01, 
        reward: {
            type: 'currency',
            name: '–°–æ–∫—Ä–æ–≤–∏—â–µ',
            emoji: 'üíé',
            rarity: 'legendary'
        }
    }
];


# ./src/types/embedTypes.ts
export interface TopUser {
    user: { discordId: string };
    value: bigint | number | string;
    displayValue: string;
  }
  
export interface TopEmbedOptions {
    title: string;
    description: string;
    icon?: string;
    color?: number;
}

# ./src/main.ts
import { dirname, importx } from "@discordx/importer";
import type { Interaction, Message } from "discord.js";
import { IntentsBitField } from "discord.js";
import { Client } from "discordx";
import { AppDataSource } from "./services/database.js";
import { seedDefaultConfigs } from "./services/initDatabase.js";
import { setDiscordClient } from "./utils/decorators/CheckLevelUp.js";
import { setDiscordClient as setDiscordClientGifts } from "./utils/decorators/CheckGiftProgress.js"; 

export const bot = new Client({
  intents: [
    IntentsBitField.Flags.Guilds,
    IntentsBitField.Flags.GuildMembers,
    IntentsBitField.Flags.GuildMessages,
    IntentsBitField.Flags.GuildMessageReactions,
    IntentsBitField.Flags.GuildVoiceStates,
    IntentsBitField.Flags.MessageContent,
  ],
  silent: false,
  simpleCommand: {
    prefix: "!",
  },
});

async function run() {
  try {
    await AppDataSource.initialize();
    console.log("‚úÖ Database connected!");
    await seedDefaultConfigs();
    console.log("‚úÖ Data Source has been initialized!");
  } catch (error) {
    console.error("üí• Database connection error:", error);
    process.exit(1);
  }

  try {
    console.log("üì¶ –ò–º–ø–æ—Ä—Ç –∫–æ–º–∞–Ω–¥...");
    await importx(`${dirname(import.meta.url)}/{events,commands}/**/*.{ts,js}`);
    console.log("‚úÖ –ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–µ–Ω");
  } catch (err) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ —Ñ–∞–π–ª–æ–≤:", err);
    process.exit(1);
  }
  if (!process.env.BOT_TOKEN) {
    throw Error("Could not find BOT_TOKEN in your environment");
  }

  await bot.login(process.env.BOT_TOKEN);
}

bot.once("ready", async () => {
  await bot.initApplicationCommands();
  setDiscordClient(bot);
  setDiscordClientGifts(bot);

  bot.user?.setActivity({
    name: "–º—É—Ä—á–∞–Ω–∏–µ Kitsune",
    type: 2 
  });

  console.log("ü§ñ Bot started");
});

bot.on("interactionCreate", (interaction: Interaction) => {
  bot.executeInteraction(interaction);
});

bot.on("messageCreate", (message: Message) => {
  void bot.executeCommand(message);
});

void run();


# ./src/constants/colors.ts
export const RARITY_COLORS = {
    common: 0x808080,     
    uncommon: 0x4CAF50,   
    rare: 0x2196F3,
    epic: 0x9C27B0,   
    legendary: 0xFFC107  
};

# ./src/utils/levelUpUtils.ts
/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç —Ç—Ä–µ–±—É–µ–º—ã–π –æ–ø—ã—Ç –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è
 * 19 —É—Ä–æ–≤–µ–Ω—å = 1–º–ª–Ω –æ–ø—ã—Ç–∞, 20 —É—Ä–æ–≤–µ–Ω—å = 2–º–ª–Ω –æ–ø—ã—Ç–∞
 * –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å - 20
 * 
 * @param level —Ü–µ–ª–µ–≤–æ–π —É—Ä–æ–≤–µ–Ω—å
 * @returns –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø—ã—Ç–∞, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è
 */
export function getExpForLevel(level: number): bigint {
    if (level > 20) {
        return getExpForLevel(20);
    }
        if (level <= 19) {
        const baseValue = 85;         
        const factor = 700;            
        const power = 2.53;          
        
        const linearComponent = baseValue * level;
        const exponentialComponent = factor * Math.pow(level - 1, power);
        return BigInt(Math.floor(linearComponent + exponentialComponent));
    } else {
        return BigInt(2000000);
    }
}

/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç —Ç—Ä–µ–±—É–µ–º—ã–π –æ–ø—ã—Ç –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
 * @param level —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å
 */
export function calculateNextLevelExp(currentLevel: number): bigint {
    if (currentLevel >= 20) {
        return BigInt(0);
    }
    return getExpForLevel(currentLevel + 1);
}

/**
 * –ù–∞—Ö–æ–¥–∏—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –¥–æ—Å—Ç–∏—á—å —Å —Ç–µ–∫—É—â–∏–º –æ–ø—ã—Ç–æ–º
 * @param currentExp —Ç–µ–∫—É—â–∏–π –æ–ø—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @param startLevel —É—Ä–æ–≤–µ–Ω—å —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–∞—á–∏–Ω–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
 * @returns –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑–º–æ–∂–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å
 */
export function getMaxLevelForExp(currentExp: bigint, startLevel: number = 1): number {
    let level = startLevel;
    
    while (level < 20) {
        const nextLevelExp = getExpForLevel(level + 1);
        if (currentExp < nextLevelExp) {
            break;
        }
        level++;
    }
    
    return level;
}

/**
 * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç, —Å–∫–æ–ª—å–∫–æ –æ–ø—ã—Ç–∞ –æ—Å—Ç–∞–ª–æ—Å—å –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
 * @param currentExp —Ç–µ–∫—É—â–∏–π –æ–ø—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @param currentLevel —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø—ã—Ç–∞, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
 */
export function getExpToNextLevel(currentExp: bigint, currentLevel: number): bigint {
    if (currentLevel >= 20) {
        return BigInt(0); 
    }
    
    const nextLevelExp = getExpForLevel(currentLevel + 1);
    return nextLevelExp - currentExp;
}

/**
 * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É—Ä–æ–≤–Ω—é
 * @param currentExp —Ç–µ–∫—É—â–∏–π –æ–ø—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @param currentLevel —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ (–æ—Ç 0 –¥–æ 100)
 */
export function getProgressToNextLevel(currentExp: bigint, currentLevel: number): number {
    if (currentLevel >= 20) {
        return 100;
    }
    
    const currentLevelExp = getExpForLevel(currentLevel);
    const nextLevelExp = getExpForLevel(currentLevel + 1);
    
    const totalExpNeeded = nextLevelExp - currentLevelExp;
    const expGained = currentExp - currentLevelExp;
    
    return Math.floor(Number(expGained * BigInt(100)) / Number(totalExpNeeded));
}

/**
 * –ü—Ä–∏–º–µ—Ä–Ω—ã–π —Ä–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ (–≤ –¥–Ω—è—Ö) –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
 * –ø—Ä–∏ —Ç–µ–∫—É—â–µ–º —Ç–µ–º–ø–µ –Ω–∞–±–æ—Ä–∞ –æ–ø—ã—Ç–∞
 * @param expToNextLevel –æ–ø—ã—Ç, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–π –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
 * @param avgDailyXP —Å—Ä–µ–¥–Ω–∏–π –¥–Ω–µ–≤–Ω–æ–π –Ω–∞–±–æ—Ä –æ–ø—ã—Ç–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1500)
 * @returns –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π
 */
export function getDaysToNextLevel(expToNextLevel: bigint, avgDailyXP: number = 1500): number {
    return Math.ceil(Number(expToNextLevel) / avgDailyXP);
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å
 * @param level —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å
 * @returns true, –µ—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å
 */
export function isMaxLevel(level: number): boolean {
    return level >= 20;
}

/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –≤ –¥–Ω—è—Ö –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è
 * @param targetLevel —Ü–µ–ª–µ–≤–æ–π —É—Ä–æ–≤–µ–Ω—å
 * @param avgDailyXP —Å—Ä–µ–¥–Ω–∏–π –¥–Ω–µ–≤–Ω–æ–π –Ω–∞–±–æ—Ä –æ–ø—ã—Ç–∞
 * @returns –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è
 */
export function getDaysToLevel(targetLevel: number, avgDailyXP: number = 1500): number {
    if (targetLevel <= 0 || targetLevel > 20) {
        return 0;
    }
    
    const requiredExp = getExpForLevel(targetLevel);
    return Math.ceil(Number(requiredExp) / avgDailyXP);
}

# ./src/utils/decorators/CheckGiftProgress.ts
import { AppDataSource } from '../../services/database.js';
import { User } from '../../entities/User.js';
import { GiftStats } from '../../entities/GiftStats.js';
import { Currency } from '../../entities/Currency.js';
import { TextChannel, EmbedBuilder, Client } from 'discord.js';
import logger from '../../services/logger.js';
import { RARITY_COLORS } from '../../constants/colors.js';
import { pluralizeGifts } from '../giftUtils.js';
import { Config } from '../../entities/Config.js';

const MINUTES_PER_GIFT = 480; 

let discordClient: Client | undefined;

export function setDiscordClient(client: Client) {
  discordClient = client;
  logger.info('Discord client —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –ø–æ–¥–∞—Ä–∫–æ–≤');
}

/**
 * –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –ø–æ–¥–∞—Ä–∫–æ–≤
 * @param discordId ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Discord
 * @param forceCheck –§–æ—Ä—Å–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –≤–æ–π—Å–∞)
 * @returns –û–±—ä–µ–∫—Ç —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –Ω–∞—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –ø–æ–¥–∞—Ä–∫–∞—Ö –∏–ª–∏ null
 */
export async function checkAndProcessGifts(discordId: string, forceCheck: boolean = false): Promise<{
  newGifts: number;
  totalAvailable: number;
} | null> {
  try {
    const userRepo = AppDataSource.getRepository(User);
    const giftRepo = AppDataSource.getRepository(GiftStats);

    const user = await userRepo.findOne({ 
      where: { discordId },
      relations: ["exp", "currency", "giftStats"]
    });
    
    if (!user) {
      logger.warn(`checkAndProcessGifts: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è ID ${discordId}`);
      return null;
    }

    let giftStats = await giftRepo.findOne({ where: { discordId } });
    if (!giftStats) {
      giftStats = giftRepo.create({
        discordId,
        userId: user.id,
        user,
        trackedVoiceMinutes: user.voiceMinutes, 
        claimedGiftsFromVoice: 0,
        totalGiftsClaimed: 0,
        availableGifts: 0,
        lastDailyGiftClaim: null
      });
      
      logger.debug(`checkAndProcessGifts: –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å GiftStats –¥–ª—è ${discordId}`);
    } else if (forceCheck) {
      if (user.voiceMinutes > giftStats.trackedVoiceMinutes) {
        logger.info(`checkAndProcessGifts: –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å—á–µ—Ç—á–∏–∫–æ–≤ –¥–ª—è ${discordId}. user.voiceMinutes=${user.voiceMinutes}, giftStats.trackedVoiceMinutes=${giftStats.trackedVoiceMinutes}`);
        giftStats.trackedVoiceMinutes = user.voiceMinutes;
      }
    }

    const minutes = Number(user.voiceMinutes);
    const potentialGifts = Math.floor(minutes / MINUTES_PER_GIFT);
    
    const newGifts = potentialGifts - giftStats.claimedGiftsFromVoice;
    
    if (newGifts <= 0 && !forceCheck) {
      return null; 
    }
    
    if (newGifts > 0) {
      giftStats.claimedGiftsFromVoice += newGifts;
      giftStats.availableGifts += newGifts;
      
      logger.info(`checkAndProcessGifts: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordId} –ø–æ–ª—É—á–∏–ª ${newGifts} –ø–æ–¥–∞—Ä–∫–æ–≤. –í—Å–µ–≥–æ –¥–æ—Å—Ç—É–ø–Ω–æ: ${giftStats.availableGifts}`);
      
      await giftRepo.save(giftStats);
      
      return {
        newGifts,
        totalAvailable: Number(giftStats.availableGifts)
      };
    } else if (forceCheck) {
      await giftRepo.save(giftStats);
      logger.debug(`checkAndProcessGifts: –§–æ—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –¥–ª—è ${discordId} –±–µ–∑ –Ω–æ–≤—ã—Ö –ø–æ–¥–∞—Ä–∫–æ–≤`);
    }
    
    return null;
  } catch (error) {
    logger.error(`checkAndProcessGifts error: ${error}`);
    return null;
  }
}

/**
 * –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –ø–æ–¥–∞—Ä–∫–æ–≤
 */
export function CheckGiftProgress() {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    descriptor.value = async function (...args: any[]) {
      await originalMethod.apply(this, args);

      try {
        let discordId: string | undefined;
        const firstArg = args[0];
        if (typeof firstArg === 'string') {
          discordId = firstArg;
        } else if (firstArg?.author?.id) {
          discordId = firstArg.author.id;
        } else if (Array.isArray(firstArg) && (firstArg[1]?.member?.id || firstArg[0]?.member?.id)) {
          discordId = firstArg[1]?.member?.id || firstArg[0]?.member?.id;
        } else if (args.find(arg => arg?.user?.id)) {
          const interaction = args.find(arg => arg?.user?.id);
          discordId = interaction.user.id;
        }
        
        if (!discordId) return;
        
        const giftResult = await checkAndProcessGifts(discordId);
        
        if (giftResult && giftResult.newGifts > 0) {
          await sendGiftNotification(discordId, giftResult.newGifts, giftResult.totalAvailable);
        }
      } catch (error) {
        logger.error(`CheckGiftProgress decorator error: ${error}`);
      }
    };
    return descriptor;
  };
}

/**
 * –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –ø–æ–¥–∞—Ä–∫–∞—Ö –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * –∏–ª–∏ –≤ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –∫–∞–Ω–∞–ª –ø—Ä–∏ –æ—à–∏–±–∫–µ
 */
export async function sendGiftNotification(
  discordId: string,
  giftCount: number,
  totalAvailable: number
) {
    if (!discordClient?.isReady()) { 
        logger.error('Discord client not initialized or not ready for gift notifications');
        return;
    }

  const embed = new EmbedBuilder()
    .setColor(RARITY_COLORS.epic)
    .setTitle(`üéÅ –í—ã –ø–æ–ª—É—á–∏–∏–ª–∏ ${giftCount} ${pluralizeGifts(giftCount)}!`)
    .setDescription(
      `–ó–∞ ${(giftCount * 8)} —á–∞—Å–æ–≤ –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ –≤—ã –ø–æ–ª—É—á–∏–ª–∏ ${giftCount} ${pluralizeGifts(giftCount)}.` +
      `\n\n–£ –≤–∞—Å —Ç–µ–ø–µ—Ä—å ${totalAvailable} ${pluralizeGifts(totalAvailable)} –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è.`
    )
    .addFields({
      name: 'üí° –ö–∞–∫ –æ—Ç–∫—Ä—ã—Ç—å –ø–æ–¥–∞—Ä–∫–∏',
      value: '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/opengift`, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Å–≤–æ–∏ –ø–æ–¥–∞—Ä–∫–∏ –∏ –ø–æ–ª—É—á–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É!',
    })
    .setTimestamp()
    .setFooter({ text: '–ü–æ–¥–∞—Ä–∫–∏ –≤—ã–¥–∞—é—Ç—Å—è –∑–∞ –∫–∞–∂–¥—ã–µ 8 —á–∞—Å–æ–≤ –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ' });

  try {
    const user = await discordClient.users.fetch(discordId);
    await user.send({ embeds: [embed] });
    logger.info(`Sent gift notification to ${user.tag} in DM`);
    return;  
  } catch (dmError) {
    logger.warn(`Cannot send gift DM to ${discordId}, trying fallback channel: ${dmError}`);
  }

  try {
    const configRepo = AppDataSource.getRepository(Config);
    const config = await configRepo.findOneBy({ key: 'user_command_channel' });

    if (!config) {
      logger.error("Fallback channel ID not found in config");
      return;
    }

    const channelId = config.value;
    const channel = await discordClient.channels.fetch(channelId) as TextChannel;

    if (!channel || !channel.isTextBased()) {
      logger.error(`Fallback channel ${channelId} is invalid`);
      return;
    }

    const publicEmbed = new EmbedBuilder()
      .setColor(RARITY_COLORS.epic)
      .setTitle(`üéÅ <@${discordId}> –ø–æ–ª—É—á–∏–ª ${giftCount} ${pluralizeGifts(giftCount)}!`)
      .setDescription(`–¢–µ–ø–µ—Ä—å —É –Ω–µ–≥–æ ${totalAvailable} ${pluralizeGifts(totalAvailable)} –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è!`)
      .addFields({
        name: 'üí° –ö–∞–∫ –æ—Ç–∫—Ä—ã—Ç—å –ø–æ–¥–∞—Ä–∫–∏',
        value: '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/opengift`, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Å–≤–æ–∏ –ø–æ–¥–∞—Ä–∫–∏ –∏ –ø–æ–ª—É—á–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É!',
      })
      .setTimestamp();

    await channel.send({ embeds: [publicEmbed] });
    logger.info(`Sent gift notification for ${discordId} in fallback channel`);
  } catch (fallbackError) {
    logger.error(`sendGiftNotification fallback error for ${discordId}: ${fallbackError}`);
  }
}

# ./src/utils/decorators/EnsureUserGuard.ts
import { GuardFunction } from "discordx";
import { 
  ChatInputCommandInteraction,
  CacheType
} from "discord.js";
import { ApplicationCommandOptionType, User as DiscordUser } from "discord.js";
import { AppDataSource } from "../../services/database.js";
import { User } from "../../entities/User.js";
import { Exp } from "../../entities/Exp.js";
import { Currency } from "../../entities/Currency.js";
import { GiftStats } from "../../entities/GiftStats.js";
import logger from "../../services/logger.js";

export function EnsureUserGuard(): GuardFunction<ChatInputCommandInteraction<CacheType>, any> {
    return async (interaction, _, next) => {
      try {
        if (!interaction || !interaction.user) {
          logger.error("EnsureUserGuard: Invalid interaction or user");
          return;
        }

        const commandUsers: DiscordUser[] = [];
        
        try {
          if (interaction.options && interaction.options.data) {
            for (const option of interaction.options.data) {
              try {
                if (option.type === ApplicationCommandOptionType.User && option.user) {
                  commandUsers.push(option.user);
                }
                
                if (option.options) {
                  for (const subOption of option.options) {
                    if (subOption.type === ApplicationCommandOptionType.User && subOption.user) {
                      commandUsers.push(subOption.user);
                    }
                  }
                }
              } catch (optionError) {
                logger.error("Error processing command option:", optionError);
              }
            }
          }
        } catch (interactionTypeError) {
          logger.error("Error determining interaction type:", interactionTypeError);
        }
  
        try {
          const hasBot = commandUsers.some(user => user?.bot);
          if (hasBot) {
            if (!interaction.replied && !interaction.deferred) {
              try {
                await interaction.reply({
                  content: "‚ö†Ô∏è –ë–æ—Ç–æ–≤ –Ω–µ–ª—å–∑—è –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å!",
                  ephemeral: true
                });
              } catch (replyError) {
                logger.error("Error replying to interaction:", replyError);
              }
            }
            return;
          }
        } catch (botCheckError) {
          logger.error("Error checking for bots:", botCheckError);
        }
  
        try {
          const users = [...commandUsers, interaction.user].filter(Boolean);
    
          const uniqueUsers = users
            .filter(user => !user?.bot)
            .filter((user, index, arr) => 
              arr.findIndex(u => u?.id === user?.id) === index
            );
    
          for (const user of uniqueUsers) {
            try {
              if (user && user.id) {
                await createUserIfNeeded(user.id);
              }
            } catch (createUserError) {
              logger.error(`Error creating user ${user?.id}:`, createUserError);
            }
          }
        } catch (userProcessingError) {
          logger.error("Error processing users:", userProcessingError);
        }
  
        try {
          if (AppDataSource.manager.queryRunner?.isTransactionActive) {
            await AppDataSource.manager.queryRunner?.commitTransaction();
          }
        } catch (transactionError) {
          logger.error("Error committing transaction:", transactionError);
        }
        
        await next();
      } catch (error) {
        logger.error("EnsureUserGuard error:", error);
        
        try {
          if (interaction && !interaction.replied && !interaction.deferred) {
            await interaction.reply({
              content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
              ephemeral: true
            });
          } else if (interaction && interaction.deferred && !interaction.replied) {
            await interaction.editReply({
              content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
            });
          }
        } catch (responseError) {
          logger.error("Failed to send error response:", responseError);
        }
        
        await next(); 
      }
    };
}

async function createUserIfNeeded(discordId: string): Promise<void> {
  const userRepo = AppDataSource.getRepository(User);
  
  try {
    const existingUser = await userRepo.findOne({ 
      where: { discordId },
      relations: ["exp", "currency", "giftStats"]
    });

    if (existingUser) return;

    logger.info(`[EnsureUserGuard] –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}`);

    await AppDataSource.transaction(async (transactionalEntityManager) => {
      const newUser = userRepo.create({
        discordId,
        messageCount: 0n,
        voiceMinutes: 0n
      });

      const savedUser = await transactionalEntityManager.save(newUser);

      const exp = new Exp();
      exp.exp = 0n;
      exp.level = 1;
      exp.user = savedUser;
      await transactionalEntityManager.save(exp);

      const currency = new Currency();
      currency.currencyCount = 1000n;
      currency.user = savedUser;
      await transactionalEntityManager.save(currency);

      const giftStats = new GiftStats();
      giftStats.discordId = discordId;
      giftStats.user = savedUser;
      giftStats.trackedVoiceMinutes = 0n;
      giftStats.claimedGiftsFromVoice = 0;
      giftStats.totalGiftsClaimed = 0;
      giftStats.availableGifts = 0;
      await transactionalEntityManager.save(giftStats);
    });

    logger.info(`[EnsureUserGuard] –£—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordId}`);
  } catch (error) {
    logger.error(`[EnsureUserGuard] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}:`, error);
    throw error;
  }
}

# ./src/utils/decorators/CheckMoney.ts
import { ButtonInteraction, CommandInteraction } from "discord.js";
import { GuardFunction } from "discordx";
import { AppDataSource } from "../../services/database.js";
import { User } from "../../entities/User.js";
import logger from "../../services/logger.js";

interface DuelData {
    bet: number;
    creatorId: string;
}

export function CheckMoney(): GuardFunction<CommandInteraction | ButtonInteraction> {
    return async (interaction, _, next) => {
        try {
            if (interaction.replied || interaction.deferred) {
                logger.warn("CheckMoney: Interaction already replied or deferred");
                return next(); 
            }

            let bet: number;
            let targetUserId: string | undefined;
            
            if (interaction instanceof CommandInteraction) {
                const betOption = interaction.options.get("bet");
                if (!betOption?.value) {
                    await interaction.reply({
                        content: "‚ùå –£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏",
                        ephemeral: true
                    });
                    return;
                }
                bet = betOption.value as number;
            } else {
                const match = interaction.customId.match(/duel_(\d+)_(\d+)/);
                if (!match) {
                    await interaction.reply({
                        content: "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥—É—ç–ª–∏",
                        ephemeral: true
                    });
                    return;
                }
                bet = parseInt(match[2]);
                targetUserId = match[1];
            }

            if (bet <= 0) {
                await interaction.reply({
                    content: "‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞ —Å—Ç–∞–≤–∫–∏",
                    ephemeral: true
                });
                return;
            }

            const userRepo = AppDataSource.getRepository(User);
            const user = await userRepo.findOne({
                where: { discordId: interaction.user.id },
                relations: ["currency"]
            });

            if (!user?.currency) {
                await interaction.reply({
                    content: "‚ùå –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω",
                    ephemeral: true
                });
                return;
            }

            if (user.currency.currencyCount < BigInt(bet)) {
                await interaction.reply({
                    content: "‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤",
                    ephemeral: true
                });
                return;
            }

            if (targetUserId) {
                const targetUser = await userRepo.findOne({
                    where: { discordId: targetUserId },
                    relations: ["currency"]
                });

                if (!targetUser?.currency) {
                    await interaction.reply({
                        content: "‚ùå –û–ø–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω",
                        ephemeral: true
                    });
                    return;
                }

                if (targetUser.currency.currencyCount < BigInt(bet)) {
                    await interaction.reply({
                        content: "‚ùå –£ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤",
                        ephemeral: true
                    });
                    return;
                }
            }
            
            await next();
        } catch (error) {
            logger.error("CheckMoney error:", error);
            
            try {
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({
                        content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–ª–∞–Ω—Å–∞",
                        ephemeral: true
                    });
                }
            } catch (replyError) {
                logger.error("Failed to send error response:", replyError);
            }
        }
    };
}

# ./src/utils/decorators/EnsureUsers.ts
import { AppDataSource } from "../../services/database.js";
import { User } from "../../entities/User.js";
import { Exp } from "../../entities/Exp.js";
import { Currency } from "../../entities/Currency.js";
import { GiftStats } from "../../entities/GiftStats.js";
import logger from "../../services/logger.js";

/**
 * –î–µ–∫–æ—Ä–∞—Ç–æ—Ä, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—â–∏–π —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.
 * –í—Å–µ–≥–¥–∞ —Å–æ–∑–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å—É—â–Ω–æ—Å—Ç–∏, –µ—Å–ª–∏ –æ–Ω–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.
 * –ë–æ—Ç—ã –Ω–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.
 */
export function EnsureUser() {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      let discordId: string | undefined;
      let isBot: boolean = false;

      if (args[0]?.author?.id) {
        discordId = args[0].author.id;
        isBot = args[0].author.bot === true;
      }
      else if (args[0]?.[0]?.member?.id || args[0]?.[1]?.member?.id) {
        discordId = (args[0][1]?.member?.id || args[0][0]?.member?.id);
        isBot = (args[0][1]?.member?.user?.bot === true || args[0][0]?.member?.user?.bot === true);
      }
      else if (args.find(arg => arg?.user?.id || arg?.member?.id)) {
        const interaction = args.find(arg => arg?.user?.id || arg?.member?.id);
        discordId = interaction.user?.id || interaction.member?.id;
        isBot = interaction.user?.bot === true || interaction.member?.user?.bot === true;
      }
      else if (args.find(arg => arg?.id && typeof arg.id === 'string')) {
        const userArg = args.find(arg => arg?.id && typeof arg.id === 'string');
        discordId = userArg.id;
        isBot = userArg.bot === true;
      }

      if (!discordId) {
        logger.warn(`EnsureUser: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ ${propertyKey}`);
        return originalMethod.apply(this, args);
      }

      if (isBot) {
        logger.debug(`EnsureUser: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordId} —è–≤–ª—è–µ—Ç—Å—è –±–æ—Ç–æ–º, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º`);
        return originalMethod.apply(this, args);
      }

      try {
        const userRepository = AppDataSource.getRepository(User);
        const expRepository = AppDataSource.getRepository(Exp);
        const currencyRepository = AppDataSource.getRepository(Currency);
        const giftStatsRepository = AppDataSource.getRepository(GiftStats);

        let user = await userRepository.findOne({
          where: { discordId },
          relations: ["exp", "currency"]
        });

        if (!user) {
          logger.info(`EnsureUser: –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}`);

          user = userRepository.create({
            discordId,
            messageCount: 0n,
            voiceMinutes: 0n
          });
          await userRepository.save(user);
        }

        if (!user.exp) {
          const newExp = expRepository.create({
            exp: 0n,
            level: 1,
            user
          });
          await expRepository.save(newExp);
          logger.debug(`EnsureUser: –°–æ–∑–¥–∞–Ω–∞ –∑–∞–ø–∏—Å—å –æ–ø—ã—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}`);
        }

        if (!user.currency) {
          const newCurrency = currencyRepository.create({
            currencyCount: 1000n,
            user
          });
          await currencyRepository.save(newCurrency);
          logger.debug(`EnsureUser: –°–æ–∑–¥–∞–Ω–∞ –∑–∞–ø–∏—Å—å –≤–∞–ª—é—Ç—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}`);
        }

        const giftStats = await giftStatsRepository.findOne({
          where: { discordId }
        });

        if (!giftStats) {
          const newGiftStats = giftStatsRepository.create({
            discordId,
            userId: user.id,
            user,
            trackedVoiceMinutes: user.voiceMinutes,
            claimedGiftsFromVoice: 0,
            totalGiftsClaimed: 0
          });
          await giftStatsRepository.save(newGiftStats);
          logger.debug(`EnsureUser: –°–æ–∑–¥–∞–Ω–∞ –∑–∞–ø–∏—Å—å GiftStats –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}`);
        }

      } catch (error) {
        logger.error(`EnsureUser: –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordId}: %O`, error);
      }

      return originalMethod.apply(this, args);
    };

    return descriptor;
  };
}

# ./src/utils/decorators/RequireRoles.ts
import { ButtonInteraction, CommandInteraction } from "discord.js";
import { GuardFunction } from "discordx";
import { userHasAnyRoleFromConfig } from "../userHasAnyRoleFromConfig.js";
import logger from "../../services/logger.js";

/**
 * Guard –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –∫–æ–º–∞–Ω–¥ + –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–æ–ª–µ–π (–∞–Ω–∞–ª–æ–≥ CheckMoney)
 * @param configKeys - –ö–ª—é—á–∏ —Ä–æ–ª–µ–π –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, ["admin_role_id"])
 * @param denyMessage - –°–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
 */
export const RequireRoles: (
    configKeys: string[],
    denyMessage?: string
) => GuardFunction<CommandInteraction> = (
    configKeys,
    denyMessage = "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã"
) => {
    return async (interaction, _, next) => {
        try {
            const hasAccess = await userHasAnyRoleFromConfig(interaction, configKeys);

            if (!hasAccess) {
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({
                        content: denyMessage,
                        ephemeral: true,
                    });
                }
                return; 
            }

            await next();
        } catch (error) {
            logger.error(`RequireRolesHide Error (${interaction.commandName}):`, error);
            
            if (interaction.replied || interaction.deferred) {
                await interaction.followUp({
                    content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞",
                    ephemeral: true,
                });
            } else {
                await interaction.reply({
                    content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞",
                    ephemeral: true,
                });
            }
        }
    };
};

# ./src/utils/decorators/ChannelGuard.ts
import { GuardFunction } from "discordx";
import type { CommandInteraction } from "discord.js";
import { AppDataSource } from "../../services/database.js";
import { Config } from "../../entities/Config.js";
import { MessageFlags } from "discord.js";
import logger from "../../services/logger.js";

export function ChannelGuard(configKey: string): GuardFunction<CommandInteraction> {
  return async (interaction, _client, next) => {
    try {
      if (!interaction || !interaction.user || !interaction.channelId) {
        logger.error(`ChannelGuard: Invalid interaction for '${configKey}'`);
        return;
      }

      const configRepo = AppDataSource.getRepository(Config);
      const configs = await configRepo.find({ where: { key: configKey } });

      if (configs.length === 0) {
        logger.warn(`ChannelGuard: config '${configKey}' not found`);
        
        if (!interaction.replied && !interaction.deferred) {
          try {
            await interaction.reply({
              content: "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–∞–Ω–∞–ª. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
              flags: MessageFlags.Ephemeral,
            });
          } catch (replyError) {
            logger.error("Failed to reply in ChannelGuard (config not found):", replyError);
          }
        }
        return;
      }

      const allowedChannelIds = configs
        .flatMap(c => c.value.split(","))
        .map(id => id.trim())
        .filter(id => id);

      if (!allowedChannelIds.length) {
        logger.warn(`ChannelGuard: no channels configured for '${configKey}'`);
        
        if (!interaction.replied && !interaction.deferred) {
          try {
            await interaction.reply({
              content: "‚ùå –ù–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.",
              flags: MessageFlags.Ephemeral,
            });
          } catch (replyError) {
            logger.error("Failed to reply in ChannelGuard (no channels):", replyError);
          }
        }
        return;
      }

      if (!allowedChannelIds.includes(interaction.channelId)) {
        const list = allowedChannelIds.map(id => `<#${id}>`).join(", ");
        
        if (!interaction.replied && !interaction.deferred) {
          try {
            await interaction.reply({
              content: `‚ùå –≠—Ç—É –∫–æ–º–∞–Ω–¥—É –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –∫–∞–Ω–∞–ª–∞—Ö: ${list}`,
              flags: MessageFlags.Ephemeral,
            });
          } catch (replyError) {
            logger.error("Failed to reply in ChannelGuard (wrong channel):", replyError);
          }
        }
        return;
      }

      await next();
    } catch (error) {
      logger.error(`ChannelGuard error for '${configKey}':`, error);
      
      try {
        if (interaction && !interaction.replied && !interaction.deferred) {
          await interaction.reply({
            content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–Ω–∞–ª–∞",
            flags: MessageFlags.Ephemeral,
          });
        }
      } catch (responseError) {
        logger.error("Failed to send error response in ChannelGuard:", responseError);
      }
      
      await next();
    }
  };
}

# ./src/utils/decorators/CustomBackgroundDecorator.ts
import { AppDataSource } from "../../services/database.js";
import { Config } from "../../entities/Config.js";
import logger from "../../services/logger.js";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
import { User } from "discord.js";

type ProfileImageParams = [
  user: User,
  messageCount: number,
  voiceMinutes: number,
  level: number,
  currency: number,
  progressPercent: number,
  backgroundImagePath?: string
];

/**
 * –î–µ–∫–æ—Ä–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞ –¥–ª—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø—É—Ç—å –∫ –Ω–µ–º—É –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è
 */
export function WithCustomBackground() {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      try {
        const interaction = args[args.length - 1];
        const targetUser = args[0] || interaction.user;
        
        logger.info(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${targetUser.id}`);
        
        const customBackgroundPath = await getCustomBackgroundPath(targetUser.id);
        
        if (customBackgroundPath) {
          logger.info(`–ù–∞–π–¥–µ–Ω –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetUser.id}: ${customBackgroundPath}`);
          
          const self = this;
          
          const newArgs = [...args, customBackgroundPath];
          
          return await originalMethod.apply(self, newArgs);
        } else {
          logger.info(`–ö–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetUser.id} –Ω–µ –Ω–∞–π–¥–µ–Ω`);
        }

        return originalMethod.apply(this, args);
      } catch (error) {
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞: %O", error);
        return originalMethod.apply(this, args);
      }
    };

    return descriptor;
  };
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –ø—É—Ç—å –∫ –∫–∞—Å—Ç–æ–º–Ω–æ–º—É —Ñ–æ–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
 * @param userId ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º —Ñ–æ–Ω–æ–º –∏–ª–∏ null
 */
async function getCustomBackgroundPath(userId: string): Promise<string | null> {
  try {
    const configRepo = AppDataSource.getRepository(Config);
    const customBackgroundConfig = await configRepo.findOne({
      where: { key: "custom_background", value: userId }
    });
    
    if (!customBackgroundConfig) {
      logger.info(`–ó–∞–ø–∏—Å—å –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
      return null;
    }

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const assetsPath = path.join(__dirname, '../../../assets/images');
    
    const customBackgroundFilename = `${userId}.png`;
    const customBackgroundFullPath = path.join(assetsPath, customBackgroundFilename);
    
    if (fs.existsSync(customBackgroundFullPath)) {
      logger.info(`–ù–∞–π–¥–µ–Ω —Ñ–∞–π–ª –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: ${customBackgroundFullPath}`);
      return customBackgroundFullPath;
    }
    
    logger.warn(`–ö–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –Ω–∞—Å—Ç—Ä–æ–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}, –Ω–æ —Ñ–∞–π–ª ${customBackgroundFilename} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ ${assetsPath}`);
    return null;
  } catch (error) {
    logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞: %O", error);
    return null;
  }
}

# ./src/utils/decorators/BlockVoicePresentInChannels.ts
import { AppDataSource } from "../../services/database.js";
import { Config } from "../../entities/Config.js";
import logger from "../../services/logger.js";

export function BlockVoicePresentInChannels() {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const [oldState, newState] = args[0];

      const newChannelId = newState?.channelId;
      const oldChannelId = oldState?.channelId;

      if (!newChannelId && !oldChannelId) {
        return;
      }

      try {
        const configRepo = AppDataSource.getRepository(Config);
        const ignoredConfigs = await configRepo.find({
          where: { key: "ignore_voice_channel_exp" },
        });

        const ignoredIds = ignoredConfigs.map(config => config.value.trim());

        logger.info(`Ignored channel IDs: ${JSON.stringify(ignoredIds)}`);

        if (newChannelId && ignoredIds.includes(newChannelId)) {
          logger.info(`–ö–∞–Ω–∞–ª ${newChannelId} –≤ —Å–ø–∏—Å–∫–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã—Ö. EXP –∏ –≤–∞–ª—é—Ç–∞ –Ω–∞—á–∏—Å–ª—è—Ç—å—Å—è –Ω–µ –±—É–¥—É—Ç.`);
          return;
        }

        return originalMethod.apply(this, args);
      } catch (error) {
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ignore_voice_channel_exp: %O", error);
        return;
      }
    };

    return descriptor;
  };
}

# ./src/utils/decorators/CheckLevelUp.ts
import { AppDataSource } from "../../services/database.js";
import { User } from "../../entities/User.js";
import { Exp } from "../../entities/Exp.js";
import { Currency } from "../../entities/Currency.js";
import { TextChannel, EmbedBuilder, Client, GuildMember } from "discord.js";
import logger from "../../services/logger.js";
import { calculateNextLevelExp, getMaxLevelForExp } from "../levelUpUtils.js";
import { RARITY_COLORS } from "../../constants/colors.js";
import { Config } from "../../entities/Config.js";

let discordClient: Client | undefined = undefined;

export function setDiscordClient(client: Client) {
  discordClient = client;
}

/**
 * –î–µ–∫–æ—Ä–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–≤—ã—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç.
 * –¢–∞–∫–∂–µ –≤—ã–¥–∞–µ—Ç –Ω–∞–≥—Ä–∞–¥—É –∑–∞ –ø–æ–≤—ã—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞–ª—é—Ç—ã, —Ä–∞–≤–Ω–æ–µ —É—Ä–æ–≤–Ω—é*100.
 */
export function CheckLevelUp() {
    return function (
      target: any,
      propertyKey: string,
      descriptor: PropertyDescriptor
    ) {
      const originalMethod = descriptor.value;
  
      descriptor.value = async function (...args: any[]) {
        await originalMethod.apply(this, args);
  
        try {
          let discordId: string | undefined;
          const firstArg = args[0];
  
          if (typeof firstArg === 'string') {
            discordId = firstArg;
          } else if (firstArg?.author?.id) {
            discordId = firstArg.author.id;
          } else if (firstArg?.[0]?.member?.id || firstArg?.[1]?.member?.id) {
            discordId = (firstArg[1]?.member?.id || firstArg[0]?.member?.id);
          } else if (args.find(arg => arg?.user?.id)) {
            const interaction = args.find(arg => arg?.user?.id);
            discordId = interaction.user.id;
          }
  
          if (!discordId) {
            return;
          }
  
          const userRepository = AppDataSource.getRepository(User);
          const user = await userRepository.findOne({
            where: { discordId },
            relations: ["exp", "currency"],
          });
  
          if (!user || !user.exp) {
            logger.warn(`CheckLevelUp: –ù–µ –Ω–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–ª–∏ exp –¥–ª—è ${discordId}`);
            return;
          }
  
          const currentExp = Number(user.exp.exp);
          const oldLevel = user.exp.level;
  
          const newLevel = getMaxLevelForExp(BigInt(currentExp));
  
          if (newLevel > oldLevel) {
            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordId} –ø–æ–≤—ã—Å–∏–ª —É—Ä–æ–≤–µ–Ω—å —Å ${oldLevel} –¥–æ ${newLevel}`);
  
            const expRepository = AppDataSource.getRepository(Exp);
            await expRepository.update(
              { id: user.exp.id },
              { level: newLevel }
            );
  
            const currencyRepository = AppDataSource.getRepository(Currency);
            const levelReward = newLevel * 100;
            
            await currencyRepository.increment(
              { id: user.currency.id },
              "currencyCount",
              levelReward
            );
            
            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordId} –ø–æ–ª—É—á–∏–ª ${levelReward}$ –∑–∞ –ø–æ–≤—ã—à–µ–Ω–∏–µ –¥–æ —É—Ä–æ–≤–Ω—è ${newLevel}`);
  
            await sendLevelUpMessage(discordId, newLevel, levelReward);
          }
        } catch (error) {
          logger.error(`CheckLevelUp: –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —É—Ä–æ–≤–Ω—è: ${error}`);
        }
      };
  
      return descriptor;
    };
  }

/**
 * –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è –≤ —á–∞—Ç
 */
async function sendLevelUpMessage(
    discordId: string,
    newLevel: number,
    reward: number
  ) {
    try {
      if (!discordClient) {
        logger.error("Discord Client –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è");
        return;
      }
  
      const user = await discordClient.users.fetch(discordId);
      if (!user) {
        logger.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Discord ${discordId}`);
        return;
      }
  
      const embed = new EmbedBuilder()
        .setColor(RARITY_COLORS.legendary)
        .setTitle(`üéâ –£—Ä–æ–≤–µ–Ω—å –ø–æ–≤—ã—à–µ–Ω!`)
        .setDescription(`–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ **${newLevel}** —É—Ä–æ–≤–Ω—è!`)
        .addFields(
          { name: 'üí∞ –ù–∞–≥—Ä–∞–¥–∞', value: `${reward}$`, inline: true },
        )
        .setTimestamp()
        .setFooter({ text: `–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–æ–≤—ã—à–µ–Ω–∏–µ–º —É—Ä–æ–≤–Ω—è!` });
  
      try {
        await user.send({ embeds: [embed] });
        logger.info(`–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è –≤ –õ–° –¥–ª—è ${user.tag}`);
        return;
      } catch (dmError) {
        logger.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –õ–° ${user.tag}, –ø—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ user_command_channel: ${dmError}`);
      }
  
      const configRepo = AppDataSource.getRepository(Config);
      const config = await configRepo.findOneBy({ key: 'user_command_channel' });
      if (!config) {
        logger.error("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –∑–∞–ø–∏—Å—å user_command_channel –≤ —Ç–∞–±–ª–∏—Ü–µ config");
        return;
      }
  
      const channelId = config.value;
      const channel = await discordClient.channels.fetch(channelId) as TextChannel;
  
      if (!channel || !channel.isTextBased()) {
        logger.error(`–ö–∞–Ω–∞–ª —Å id ${channelId} –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–µ–∫—Å—Ç–æ–≤—ã–º`);
        return;
      }
  
      const publicEmbed = new EmbedBuilder()
        .setColor(RARITY_COLORS.legendary)
        .setTitle(`‚ú® –ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å! ‚ú®`)
        .setDescription(`<@${discordId}> –ø–æ–≤—ã—Å–∏–ª —Å–≤–æ–π —É—Ä–æ–≤–µ–Ω—å –¥–æ **${newLevel}**!`)
        .addFields(
          { name: 'üí∞ –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ —É—Ä–æ–≤–µ–Ω—å', value: `${reward}$`, inline: true },
        )
        .setTimestamp()
        .setThumbnail(user.displayAvatarURL({ size: 256 }));
  
      await channel.send({ embeds: [publicEmbed] });
      logger.info(`–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è –≤ –∫–∞–Ω–∞–ª ${channel.name} –¥–ª—è ${user.tag}`);
    } catch (error) {
      logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è: ${error}`);
    }
  }
  

# ./src/utils/decorators/CoommandCooldown.ts
import { GuardFunction } from "discordx";
import { CommandInteraction } from "discord.js";
import { AppDataSource } from "../../services/database.js";
import { CommandCooldown } from "../../entities/CommandCooldown.js";
import logger from "../../services/logger.js";

interface CooldownOptions {
    seconds?: number;
    minutes?: number;
    hours?: number;
    days?: number;
    message?: string;
}

export function Cooldown(options: CooldownOptions | number): GuardFunction<CommandInteraction> {
    return async (interaction, _, next) => {
        let totalSeconds = 0;

        if (typeof options === "number") {
            totalSeconds = options;
        } else {
            totalSeconds =
                (options.seconds || 0) +
                (options.minutes || 0) * 60 +
                (options.hours || 0) * 3600 +
                (options.days || 0) * 86400;
        }

        const commandName = interaction.commandName;
        const userId = interaction.user.id;

        const cooldownRepository = AppDataSource.getRepository(CommandCooldown);

        try {
            const cooldown = await cooldownRepository.findOne({
                where: { userId, commandName }
            });

            const now = new Date();
            const lastUsed = cooldown?.lastUsed || new Date(0);
            const elapsedSeconds = (now.getTime() - lastUsed.getTime()) / 1000;

            if (elapsedSeconds < totalSeconds) {
                const remaining = totalSeconds - elapsedSeconds;
                const timeString = formatTime(remaining);

                const defaultMessage = `‚è≥ –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –Ω–∞ –∫—É–ª–¥–∞—É–Ω–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ ${timeString}`;
                const customMessage = typeof options === "object" ? options.message : undefined;
                await interaction.reply({
                    content: customMessage
                        ? customMessage.replace("{time}", timeString)
                        : defaultMessage,
                    ephemeral: true
                });
                return;
            }

            await next();

            await cooldownRepository.save({
                userId,
                commandName,
                lastUsed: now
            });

        } catch (error) {
            try {
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({
                        content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–ª–∞–Ω—Å–∞",
                        ephemeral: true
                    });
                }
            } catch (replyError) {
                logger.error("Failed to send error response:", replyError);
            }
        }
    };
}

function formatTime(seconds: number): string {
    const days = Math.floor(seconds / 86400);
    seconds %= 86400;
    const hours = Math.floor(seconds / 3600);
    seconds %= 3600;
    const minutes = Math.floor(seconds / 60);
    seconds = Math.floor(seconds % 60);

    const parts = [];
    if (days > 0) parts.push(`${days} –¥.`);
    if (hours > 0) parts.push(`${hours} —á.`);
    if (minutes > 0) parts.push(`${minutes} –º–∏–Ω.`);
    if (seconds > 0 || parts.length === 0) parts.push(`${seconds} —Å–µ–∫.`);

    return parts.join(" ");
}

# ./src/utils/blackjackUtils.ts
import { EmbedBuilder, User } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User as DBUser } from "../entities/User.js"; 
import { Currency } from "../entities/Currency.js";

export type Card = {
    suit: string;
    rank: string;
    value: number;
};

export type GameState = {
    playerCards: Card[];
    dealerCards: Card[];
    bet: number;
    playerTurn: boolean;
    deck: Card[];
};

export class BlackjackGame {
    private readonly suits = ["‚ô•", "‚ô¶", "‚ô£", "‚ô†"];
    private readonly ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    public readonly TAX_RATE = 0.07;

    createDeck(): Card[] {
        const deck: Card[] = [];
        for (const suit of this.suits) {
            for (const rank of this.ranks) {
                let value = parseInt(rank);
                if (isNaN(value)) {
                    value = rank === "A" ? 11 : 10;
                }
                deck.push({ suit, rank, value });
            }
        }
        return this.shuffleDeck([...deck]);
    }

    private shuffleDeck(deck: Card[]): Card[] {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    }

    calculateHand(hand: Card[]): number {
        let total = hand.reduce((sum, card) => sum + card.value, 0);
        hand.filter(card => card.rank === "A").forEach(() => {
            if (total > 21) total -= 10;
        });
        return total;
    }

    createGameEmbed(state: GameState, user: User, gameOver = false): EmbedBuilder {
        const playerTotal = this.calculateHand(state.playerCards);
        const dealerTotal = this.calculateHand(state.dealerCards);

        const embed = new EmbedBuilder()
            .setTitle(`üé∞ Blackjack - –°—Ç–∞–≤–∫–∞: ${state.bet}$`)
            .setColor("#0099ff")
            .setFooter({ text: `–ò–≥—Ä–æ–∫: ${user.username}`, iconURL: user.displayAvatarURL() })
            .setTimestamp();

        if (!gameOver) {
            embed.addFields({
                name: "–î–∏–ª–µ—Ä",
                value: `${state.dealerCards[0].rank}${state.dealerCards[0].suit} –∏ ‚ùì\n(–û—á–∫–∏: ${state.dealerCards[0].value}+?)`,
                inline: true
            });
        } else {
            embed.addFields({
                name: "–î–∏–ª–µ—Ä",
                value: state.dealerCards.map(c => `${c.rank}${c.suit}`).join(", ") +
                    `\n(–û—á–∫–∏: ${dealerTotal})`,
                inline: true
            });
        }

        embed.addFields({
            name: "–ò–≥—Ä–æ–∫",
            value: state.playerCards.map(c => `${c.rank}${c.suit}`).join(", ") +
                `\n(–û—á–∫–∏: ${playerTotal})`,
            inline: true
        });

        if (gameOver) {
            if (playerTotal > 21) {
                embed.setDescription("**–ü–µ—Ä–µ–±–æ—Ä! –í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏.**");
            } else if (dealerTotal > 21) {
                const winAmount = this.calculateWinAmount(state.bet, true);
                embed.setDescription(`**–î–∏–ª–µ—Ä –ø–µ—Ä–µ–±—Ä–∞–ª! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ ${winAmount.net}$ (–Ω–∞–ª–æ–≥ ${winAmount.tax}$)!**`);
            } else if (playerTotal > dealerTotal) {
                const winAmount = this.calculateWinAmount(state.bet, true);
                embed.setDescription(`**–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ ${winAmount.net}$ (–Ω–∞–ª–æ–≥ ${winAmount.tax}$)!**`);
            } else if (playerTotal < dealerTotal) {
                embed.setDescription("**–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏.**");
            } else {
                embed.setDescription(`**–ù–∏—á—å—è! –í–æ–∑–≤—Ä–∞—Ç —Å—Ç–∞–≤–∫–∏ ${state.bet}$.**`);
            }
        }

        return embed;
    }

    async dealerTurn(state: GameState, user: User): Promise<{ embed: EmbedBuilder; winAmount?: { gross: number; net: number; tax: number } }> {
        state.playerTurn = false;

        while (this.calculateHand(state.dealerCards) < 17) {
            state.dealerCards.push(state.deck.pop()!);
        }

        const playerTotal = this.calculateHand(state.playerCards);
        const dealerTotal = this.calculateHand(state.dealerCards);

        let result;
        if (playerTotal > 21) {
            result = { embed: this.createGameEmbed(state, user, true) };
        } else if (dealerTotal > 21) {
            const winAmount = this.calculateWinAmount(state.bet, true);
            result = { embed: this.createGameEmbed(state, user, true), winAmount };
        } else if (playerTotal > dealerTotal) {
            const winAmount = this.calculateWinAmount(state.bet, true);
            result = { embed: this.createGameEmbed(state, user, true), winAmount };
        } else if (playerTotal < dealerTotal) {
            result = { embed: this.createGameEmbed(state, user, true) };
        } else {
            const winAmount = this.calculateWinAmount(state.bet, false);
            result = { embed: this.createGameEmbed(state, user, true), winAmount };
        }

        return result;
    }

    calculateWinAmount(bet: number, isWin: boolean): { gross: number; net: number; tax: number } {
        if (!isWin) {
            return { gross: bet, net: bet, tax: 0 };
        }

        const gross = bet * 2;
        const tax = Math.floor(gross * this.TAX_RATE);
        const net = gross - tax;

        return { gross, net, tax };
    }

    async processGameResult(
        state: GameState,
        userId: string,
        isSurrender = false
    ): Promise<{ winAmount: number; result: string }> {
        const playerTotal = this.calculateHand(state.playerCards);
        const dealerTotal = this.calculateHand(state.dealerCards);

        let winAmount = 0;
        let result = "";

        if (isSurrender) {
            winAmount = Math.floor(state.bet / 2);
            result = "surrender";
        } else if (playerTotal > 21) {
            result = "bust";
        } else if (dealerTotal > 21) {
            const amount = this.calculateWinAmount(state.bet, true);
            winAmount = amount.net;
            result = "win";
        } else if (playerTotal > dealerTotal) {
            const amount = this.calculateWinAmount(state.bet, true);
            winAmount = amount.net;
            result = "win";
        } else if (playerTotal < dealerTotal) {
            result = "lose";
        } else {
            winAmount = state.bet;
            result = "push";
        }

        if (winAmount > 0) {
            const currencyRepository = AppDataSource.getRepository(Currency);
            const dbUser = await AppDataSource.getRepository(DBUser).findOneOrFail({
                where: { discordId: userId },
                relations: ["currency"]
            });

            await currencyRepository.update(
                { id: dbUser.currency.id },
                { currencyCount: dbUser.currency.currencyCount + BigInt(winAmount) }
            );
        }

        return { winAmount, result };
    }
}

# ./src/utils/embedBuilder.ts
import { EmbedBuilder, User, Guild, ColorResolvable, CommandInteraction, Message, TextDisplayBuilder, ContainerBuilder } from "discord.js";
import { calculateNextLevelExp } from "./levelUpUtils.js";
import { getHoursString } from "./hoursUtils.js";
import { GiftReward } from "../types/giftTypes.js";
import { CasinoResult } from "../types/casinoTypes.js";
import { RARITY_COLORS } from "../constants/colors.js";
import { pluralizeGifts } from "./giftUtils.js";
import { GiftStats } from "../entities/GiftStats.js";
import { TopEmbedOptions, TopUser } from "../types/embedTypes.js";
import { readFileSync } from "fs";
import { join } from 'path';

export enum EmbedColors {
  DEFAULT = 0x5865F2,
  SUCCESS = 0x57F287,
  WARNING = 0xFEE75C,
  ERROR = 0xED4245,
  INFO = 0x5DADE2,
  CURRENCY = 0xF1C40F,
  EXP = 0x9B59B6,
  GAME = 0xFCE83B
}

interface EmbedOptions {
  title?: string;
  description?: string;
  color?: ColorResolvable;
  timestamp?: boolean;
  thumbnail?: string;
  footer?: {
    text: string;
    iconURL?: string;
  };
  author?: {
    name: string;
    iconURL?: string;
    url?: string;
  };
  fields?: Array<{
    name: string;
    value: string;
    inline?: boolean;
  }>;
}

export function createEmbed(options: EmbedOptions): EmbedBuilder {
  const embed = new EmbedBuilder()
    .setColor(options.color || EmbedColors.DEFAULT);

  if (options.title) embed.setTitle(options.title);
  if (options.description) embed.setDescription(options.description);
  if (options.timestamp) embed.setTimestamp();
  if (options.thumbnail) embed.setThumbnail(options.thumbnail);

  if (options.footer) {
    embed.setFooter({
      text: options.footer.text,
      iconURL: options.footer.iconURL
    });
  }

  if (options.author) {
    embed.setAuthor({
      name: options.author.name,
      iconURL: options.author.iconURL,
      url: options.author.url
    });
  }

  if (options.fields && options.fields.length > 0) {
    embed.addFields(options.fields);
  }

  return embed;
}

export function createErrorEmbed(message: string, user?: User): EmbedBuilder {
  return createEmbed({
    title: '‚ùå –û—à–∏–±–∫–∞',
    description: message,
    color: EmbedColors.ERROR,
    timestamp: true,
    footer: user ? {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${user.username}`,
      iconURL: user.displayAvatarURL()
    } : undefined
  });
}

export function createSuccessEmbed(message: string, user?: User): EmbedBuilder {
  return createEmbed({
    title: '‚úÖ –£—Å–ø–µ—à–Ω–æ',
    description: message,
    color: EmbedColors.SUCCESS,
    timestamp: true,
    footer: user ? {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${user.username}`,
      iconURL: user.displayAvatarURL()
    } : undefined
  });
}


export function createTopEmbed(
  topUsers: TopUser[],
  limit: number,
  requestUser: User,
  guild?: Guild | null,
  options?: TopEmbedOptions
): EmbedBuilder {
  const medals = ['ü•á', 'ü•à', 'ü•â'];

  let topList = '';
  for (let i = 0; i < topUsers.length; i++) {
    const user = topUsers[i];
    const prefix = i < 3 ? medals[i] : `${i + 1}.`;
    const valueDisplay = user.displayValue ?? user.value;
    const icon = options?.icon ?? '';
    topList += `${prefix} <@${user.user.discordId}> ‚Äî **${valueDisplay}** ${icon}\n`;
  }

  return createEmbed({
    title: options?.title ?? `üèÜ –¢–æ–ø ${limit} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`,
    description: options?.description ?? '–†–µ–π—Ç–∏–Ω–≥ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π',
    color: options?.color ?? EmbedColors.DEFAULT,
    timestamp: true,
    thumbnail: guild?.iconURL() ?? undefined,
    footer: {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${requestUser.username}`,
      iconURL: requestUser.displayAvatarURL()
    },
    fields: [
      {
        name: '–†–µ–π—Ç–∏–Ω–≥',
        value: topList || '–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.'
      }
    ]
  });
}

export function createExpTopEmbed(
  topUsers: Array<{ user: { discordId: string }, exp: bigint, level: number }>,
  limit: number,
  requestUser: User,
  guild?: Guild | null
): EmbedBuilder {
  const medals = ['ü•á', 'ü•à', 'ü•â'];

  let topList = '';
  for (let i = 0; i < topUsers.length; i++) {
    const user = topUsers[i];
    const prefix = i < 3 ? medals[i] : `${i + 1}.`;
    topList += `${prefix} <@${user.user.discordId}> ‚Äî **${user.exp}** XP (—É—Ä–æ–≤–µ–Ω—å ${user.level})\n`;
  }

  return createEmbed({
    title: `üåü –¢–æ–ø ${limit} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –æ–ø—ã—Ç—É`,
    description: '–°–∞–º—ã–µ –æ–ø—ã—Ç–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–µ—Ä–≤–µ—Ä–∞',
    color: EmbedColors.EXP,
    timestamp: true,
    thumbnail: guild?.iconURL() || undefined,
    footer: {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${requestUser.username}`,
      iconURL: requestUser.displayAvatarURL()
    },
    fields: [
      {
        name: '–†–µ–π—Ç–∏–Ω–≥ –ø–æ –æ–ø—ã—Ç—É',
        value: topList || '–ü–æ–∫–∞ –Ω–∏–∫—Ç–æ –Ω–µ –∑–∞—Ä–∞–±–æ—Ç–∞–ª –æ–ø—ã—Ç'
      }
    ]
  });
}

export function createCurrencyBalanceEmbed(targetUser: User, amount: bigint, requestUser: User): EmbedBuilder {
  return createEmbed({
    title: `üí∞ –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è`,
    description: `<@${targetUser.id}> –∏–º–µ–µ—Ç **${amount}** $`,
    color: EmbedColors.CURRENCY,
    timestamp: true,
    thumbnail: targetUser.displayAvatarURL(),
    footer: {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${requestUser.username}`,
      iconURL: requestUser.displayAvatarURL()
    }
  });
}

export function createExpEmbed(targetUser: User, exp: bigint, level: number, requestUser: User): EmbedBuilder {
  return createEmbed({
    title: `‚≠ê –£—Ä–æ–≤–µ–Ω—å –∏ –æ–ø—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è`,
    description: `<@${targetUser.id}> –∏–º–µ–µ—Ç **${exp}** –æ–ø—ã—Ç–∞`,
    color: EmbedColors.EXP,
    timestamp: true,
    thumbnail: targetUser.displayAvatarURL(),
    footer: {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${requestUser.username}`,
      iconURL: requestUser.displayAvatarURL()
    },
    fields: [
      {
        name: '–¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å',
        value: `${level}`,
        inline: true
      }
    ]
  });
}


export function createProfileEmbed(
  targetUser: User,
  messageCount: bigint,
  voiceMinutes: bigint,
  exp: bigint | undefined,
  level: number | undefined,
  currency: bigint | undefined,
  requestUser: User
): EmbedBuilder {
  const voiceHours = Math.round(Number(voiceMinutes) / 6) / 10;
  const hoursString = getHoursString(voiceHours);
  const fields = [];

  if (level !== undefined) {
    fields.push({
      name: "‚≠ê –£—Ä–æ–≤–µ–Ω—å",
      value: `**${level}**`,
      inline: true
    });
  }

  if (exp !== undefined) {
    fields.push({
      name: "üåü –û–ø—ã—Ç",
      value: `**${exp}** XP`,
      inline: true
    });
  }

  fields.push(
    {
      name: "üìù –°–æ–æ–±—â–µ–Ω–∏–π",
      value: messageCount.toString(),
      inline: true
    },
    {
      name: "üéôÔ∏è –í –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–∞–Ω–∞–ª–∞—Ö",
      value: `${voiceHours} ${hoursString}`,
      inline: true
    }
  );

  if (currency !== undefined) {
    fields.push({
      name: "üí∞ –ë–∞–ª–∞–Ω—Å",
      value: `${currency} $`,
      inline: true
    });
  }

  if (exp !== undefined && level !== undefined) {
    if (level < 20) {
      const nextLevelExp = calculateNextLevelExp(level);
      const remainingExp = nextLevelExp - exp;
      const progressPercentage = Number((Number(exp) / Number(nextLevelExp) * 100).toFixed(1));

      const progressBarTotal = 20;
      const filledBlocks = Math.floor(Number(progressPercentage) / 100 * progressBarTotal);
      const emptyBlocks = progressBarTotal - filledBlocks;
      const progressBar = '‚ñà'.repeat(filledBlocks) + '‚ñë'.repeat(emptyBlocks);

      fields.push(
        {
          name: "üìä –ü—Ä–æ–≥—Ä–µ—Å—Å",
          value: `${progressBar}\n${progressPercentage}% –¥–æ —É—Ä–æ–≤–Ω—è ${level + 1}`,
          inline: false
        }
      );
    }
  }

  return createEmbed({
    title: `–ü—Ä–æ—Ñ–∏–ª—å ${targetUser.username}`,
    description: `–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <@${targetUser.id}>`,
    color: EmbedColors.INFO,
    timestamp: true,
    thumbnail: targetUser.displayAvatarURL(),
    footer: {
      text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${requestUser.username}`,
      iconURL: requestUser.displayAvatarURL()
    },
    fields: fields
  });
}
export function createCoinflipEmbed(
  userBet: Number,
  targetUser: User,
  userSide?: String,
  winMoney?: Number,
  result?: Number,
  botSide?: String,
): EmbedBuilder {
  let coinDescription = "–ú–æ–Ω–µ—Ç–∫–∞ –≤ –≤–æ–∑–¥—É—Ö–µ...";
  const fields = [];

  if (userSide !== undefined) {
    if (userSide == "eagle") {
      userSide = "–û—Ä—ë–ª";
    } else {
      userSide = "–†–µ—à–∫–∞"
    }
  }

  if (userBet !== undefined) {

    fields.push({
      name: "–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞",
      value: `${userSide}, ${userBet}$`,
      inline: true
    })
  }

  if (botSide !== undefined) {
    if (botSide == "eagle") {
      botSide = "–æ—Ä–ª–æ–º";
    } else {
      botSide = "—Ä–µ—à–∫–æ–π"
    }
    coinDescription = `–ú–æ–Ω–µ—Ç–∫–∞ —É–ø–∞–ª–∞ ${botSide}`;
  }

  if (result == 1 && result !== undefined) {
    fields.push({
      name: "–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!",
      value: `–°—É–º–º–∞ –≤—ã–∏–≥—Ä—ã—à–∞ ${winMoney}$`,
      inline: true
    })
  }

  return createEmbed({
    title: `${targetUser.username} –ø–æ–¥–±—Ä–æ—Å–∏–ª –º–æ–Ω–µ—Ç–∫—É!`,
    description: coinDescription,
    color: EmbedColors.GAME,
    timestamp: true,
    thumbnail: targetUser.displayAvatarURL(),
    footer: {
      text: `–ò–≥—Ä–∞–µ—Ç ${targetUser.username}`,
      iconURL: targetUser.displayAvatarURL()
    },
    fields: fields
  });
}

export function createDuelEmbed(
  userBet: number,
  executeUser: User,
  targetUser?: User,
  winMoney?: number,
  winUser?: User,
  expireTimestamp?: number,  
  expired?: boolean
): EmbedBuilder {
  let duelDescription = "";

  if (winUser) {
    duelDescription = "üí• –ò—Ç–æ–≥–∏ —Å—Ö–≤–∞—Ç–∫–∏.";
  } else if (expired) {
    duelDescription = "‚è∞ –í—Ä–µ–º—è –Ω–∞ –ø—Ä–∏–Ω—è—Ç–∏–µ –¥—É—ç–ª–∏ –∏—Å—Ç–µ–∫–ª–æ.";
  } else if (expireTimestamp) {
    duelDescription = `‚öîÔ∏è –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏–Ω—è—Ç—å –¥—É—ç–ª—å –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ\nüïí –û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏: <t:${expireTimestamp}:R>`;
  } else {
    duelDescription = "‚öîÔ∏è –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏–Ω—è—Ç—å –¥—É—ç–ª—å –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.";
  }

  const fields: { name: string; value: string; inline: boolean }[] = [];

  fields.push({
    name: "üí∞ –°—Ç–∞–≤–∫–∞",
    value: `**${userBet}$**`,
    inline: true
  });

  if (winUser && targetUser) {
    const loser = targetUser.id === winUser.id ? executeUser : targetUser;
    fields.push(
      {
        name: "üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å",
        value: `<@${winUser.id}>`,
        inline: true
      },
      {
        name: "ü§ï –î—É—ç–ª—è–Ω—Ç",
        value: `<@${loser.id}>`,
        inline: true
      },
      {
        name: "üéâ –í—ã–∏–≥—Ä—ã—à",
        value: `**${winMoney}$**`,
        inline: true
      }
    );
  } else if (targetUser) {
    fields.push({
      name: "ü§∫ –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫",
      value: `<@${targetUser.id}>`,
      inline: true
    });
  }

  return createEmbed({
    title: expired
      ? `‚ùå –î—É—ç–ª—å –æ—Ç–º–µ–Ω–µ–Ω–∞`
      : winUser
        ? `üèÅ –î—É—ç–ª—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞`
        : `‚öîÔ∏è ${executeUser.username} –≤—ã–∑—ã–≤–∞–µ—Ç –Ω–∞ –¥—É—ç–ª—å!`,
    description: duelDescription,
    color: expired
      ? EmbedColors.ERROR
      : winUser
        ? EmbedColors.SUCCESS
        : EmbedColors.GAME,
    timestamp: true,
    thumbnail: executeUser.displayAvatarURL(),
    footer: {
      text: `–ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä: ${executeUser.username}`,
      iconURL: executeUser.displayAvatarURL()
    },
    fields
  });
}



/**
 * –°–æ–∑–¥–∞–µ—Ç —ç–º–±–µ–¥ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–¥–∞—Ä–∫–∞
 * @param results –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–¥–∞—Ä–∫–∞
 * @param totalWin –û–±—â–∞—è —Å—É–º–º–∞ –≤—ã–∏–≥—Ä—ã—à–∞
 * @param totalCost –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–¥–∞—Ä–∫–∞
 * @param interaction –û–±—ä–µ–∫—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
 * @returns –û–±—ä–µ–∫—Ç —ç–º–±–µ–¥–∞ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
 */
export function createGiftResultEmbed(
  results: GiftReward[],
  totalWin: number,
  totalCost: number,
  interaction: CommandInteraction
): EmbedBuilder {
  const profit = totalWin - totalCost;
  const isProfit = profit > 0;
  
  const embedColor = isProfit ? RARITY_COLORS.legendary : 
                    (totalWin === 0 ? RARITY_COLORS.common : RARITY_COLORS.rare);
  
  const embed = new EmbedBuilder()
      .setTitle(`‚ú® üéÅ –û–¢–ö–†–´–¢–ò–ï ${pluralizeGifts(results.length).toUpperCase()} üéÅ ‚ú®`)
      .setDescription(`<@${interaction.user.id}> –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç ${results.length} ${pluralizeGifts(results.length)}...`)
      .setColor(embedColor)
      .setTimestamp()
      .setThumbnail(interaction.user.displayAvatarURL({ size: 128 }));
  
  let valueText = '';
  let rewardTitle = '–ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –ø–æ–¥–∞—Ä–∫–∏';
  for (let result of results){
    if (result.type === 'nothing') {
      valueText += `${result.emoji} –ü—É—Å—Ç–æ\n`
    } else {
      valueText += `${result.emoji} ${result.name} - ${result.amount}$\n`
    }
  }

  embed.addFields({
      name: rewardTitle,
      value: `\`\`\`${valueText}\`\`\``
  });
  
  embed.addFields(
      {
          name: `${isProfit ? 'üìà' : 'üìâ'} –ò—Ç–æ–≥`,
          value: `\`${profit > 0 ? '+' : ''}${profit}$\``,
          inline: true
      }
  );
  
  if (isProfit) {
      embed.setFooter({ 
          text: 'üçÄ –£–¥–∞—á–∞ —É–ª—ã–±–Ω—É–ª–∞—Å—å –≤–∞–º! –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø—Ä–∏–±—ã–ª—å—é!',
          iconURL: interaction.user.displayAvatarURL()
      });
  } else if (totalWin === 0) {
      embed.setFooter({ 
          text: 'üòî –í —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ —Ñ–æ—Ä—Ç—É–Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–≤–µ—Ä–Ω–µ—Ç—Å—è –∫ –≤–∞–º –ª–∏—Ü–æ–º!',
          iconURL: interaction.user.displayAvatarURL()
      });
  } else {
      embed.setFooter({ 
          text: 'üé≤ –ü–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ 90% –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –º–∏–ª–ª–∏–æ–Ω–µ—Ä–æ–≤ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –ø–µ—Ä–µ–¥ –≤—ã–∏–≥—Ä—ã—à–µ–º...',
          iconURL: interaction.user.displayAvatarURL()
      });
  }
  
  return embed;
}

/**
 * –°–æ–∑–¥–∞–µ—Ç —ç–º–±–µ–¥ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∏–≥—Ä—ã –≤ –∫–∞–∑–∏–Ω–æ
 * @param bet –†–∞–∑–º–µ—Ä —Å—Ç–∞–≤–∫–∏
 * @param winAmount –°—É–º–º–∞ –≤—ã–∏–≥—Ä—ã—à–∞
 * @param result –†–µ–∑—É–ª—å—Ç–∞—Ç –∏–≥—Ä—ã (–º–Ω–æ–∂–∏—Ç–µ–ª—å, —ç–º–æ–¥–∑–∏, –æ–ø–∏—Å–∞–Ω–∏–µ)
 * @param interaction –û–±—ä–µ–∫—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
 * @returns –û–±—ä–µ–∫—Ç —ç–º–±–µ–¥–∞ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
 */
export function createCasinoResultEmbed(
  bet: number,
  winAmount: number,
  result: CasinoResult,
  interaction: CommandInteraction
): EmbedBuilder {
  const profit = winAmount - bet;
  const isWin = profit > 0;
  
  const embedColor = profit > 0 ? RARITY_COLORS.legendary : 
                    (winAmount === bet ? RARITY_COLORS.rare : RARITY_COLORS.common);
  
  const embed = new EmbedBuilder()
      .setTitle(`${result.emoji} üé∞ –ö–ê–ó–ò–ù–û üé∞ ${result.emoji}`)
      .setDescription(`<@${interaction.user.id}> –¥–µ–ª–∞–µ—Ç —Å—Ç–∞–≤–∫—É –∏ –Ω–∞–±–ª—é–¥–∞–µ—Ç –∑–∞ –≤—Ä–∞—â–µ–Ω–∏–µ–º –∫–æ–ª–µ—Å–∞ —Ñ–æ—Ä—Ç—É–Ω—ã...`)
      .setColor(embedColor)
      .setTimestamp()
      .setThumbnail(interaction.user.displayAvatarURL({ size: 128 }));
  
  let resultBlock;
  if (profit > 0) {
      resultBlock = `\`\`\`diff\n+ ${result.description}\n\`\`\``;
  } else if (winAmount === bet) {
      resultBlock = `\`\`\`fix\n${result.description}\n\`\`\``;
  } else {
      resultBlock = `\`\`\`diff\n- ${result.description}\n\`\`\``;
  }
  
  embed.addFields({
      name: `${result.emoji} –†–µ–∑—É–ª—å—Ç–∞—Ç:`,
      value: resultBlock
  });
  
  embed.addFields({
      name: '‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ‚îÖ',
      value: 'üìä **–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –æ—Ç—á–µ—Ç** üìä'
  });
  
  embed.addFields(
      {
          name: 'üí∞ –°—Ç–∞–≤–∫–∞',
          value: `\`${bet}$\``,
          inline: true
      },
      {
          name: 'üí∏ –í—ã–∏–≥—Ä—ã—à',
          value: `\`${winAmount}$\``,
          inline: true
      },
      {
          name: `${isWin ? 'üìà' : 'üìâ'} –ü—Ä–æ—Ñ–∏—Ç`,
          value: `\`${profit > 0 ? '+' : ''}${profit}$\``,
          inline: true
      }
  );
  
  if (isWin) {
      embed.setFooter({ 
          text: 'üçÄ –£–¥–∞—á–∞ –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ! –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –≤—ã–∏–≥—Ä—ã—à–µ–º!',
          iconURL: interaction.user.displayAvatarURL()
      });
  } else if (winAmount === bet) {
      embed.setFooter({ 
          text: 'üé≤ –í—ã –≤–µ—Ä–Ω—É–ª–∏ —Å–≤–æ—é —Å—Ç–∞–≤–∫—É. –ù–∏ –≤—ã–∏–≥—Ä—ã—à–∞, –Ω–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–∞.',
          iconURL: interaction.user.displayAvatarURL()
      });
  } else {
      embed.setFooter({ 
          text: 'üí∏ –ü–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ 90% –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –º–∏–ª–ª–∏–æ–Ω–µ—Ä–æ–≤ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è –ø–µ—Ä–µ–¥ –≤—ã–∏–≥—Ä—ã—à–µ–º...',
          iconURL: interaction.user.displayAvatarURL()
      });
  }
  
  return embed;
}

export function createGiftListEmbed(
  user: User,
  totalVoiceMinutes: number,
  availableGifts: number,
  claimedGifts: number,
  hoursForNextGift: number,
  remainingMinutes: number,
  giftStats: GiftStats
): EmbedBuilder {
  const fields = [];
  
  fields.push({
    name: "‚è±Ô∏è –í—Å–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–∞–Ω–∞–ª–∞—Ö:",
    value: `**${Math.floor(totalVoiceMinutes / 60)} —á ${totalVoiceMinutes % 60}**`,
  })

  fields.push({
    name: "üéÅ –î–æ—Å—Ç—É–ø–Ω–æ:",
    value: `**${availableGifts} ${pluralizeGifts(availableGifts)}**`,
  })

  fields.push({
    name: "üîÑ –ü–æ–ª—É—á–µ–Ω–æ –∑–∞ –≥–æ–ª–æ—Å:",
    value: `**${claimedGifts} ${pluralizeGifts(claimedGifts)}**`,
  })
  

  fields.push({
    name: "‚è≥ –î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ",
    value: `**${hoursForNextGift} —á ${remainingMinutes} –º–∏–Ω**`,
  })

  fields.push({
    name: "üéÅ –í—Å–µ–≥–æ –æ—Ç–∫—Ä—ã—Ç–æ: ",
    value: `**${giftStats.totalGiftsClaimed} ${pluralizeGifts(giftStats.totalGiftsClaimed)}**`,
  })
  

  return createEmbed({
    title: `–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∞—à–∏—Ö –ø–æ–¥–∞—Ä–∫–∞—Ö`,
    color: EmbedColors.GAME,
    timestamp: true,
    thumbnail: user.displayAvatarURL(),
    footer: {
      text: `–ü–æ–¥–∞—Ä–∫–∏ –Ω–∞–∫–∞–ø–ª–∏–≤–∞—é—Ç—Å—è –∑–∞ –∫–∞–∂–¥—ã–µ 8 —á–∞—Å–æ–≤`,
      iconURL: user.displayAvatarURL()
    },
    fields: fields
  });
}

/**
 * –°–æ–∑–¥–∞–µ—Ç —ç–º–±–µ–¥ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–µ—Ä–µ–≤–æ–¥–µ –≤–∞–ª—é—Ç—ã
 * @param senderUser –û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å
 * @param receiverUser –ü–æ–ª—É—á–∞—Ç–µ–ª—å
 * @param amount –°—É–º–º–∞
 * @returns –≠–º–±–µ–¥ —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ–º –æ –ø–µ—Ä–µ–≤–æ–¥–µ
 */
export function createTransferNotificationEmbed(
  senderUser: User, 
  receiverUser: User, 
  amount: number
) {
  return new EmbedBuilder()
      .setTitle("üí∞ –ü–µ—Ä–µ–≤–æ–¥ –≤–∞–ª—é—Ç—ã")
      .setDescription(`–í—ã –ø–æ–ª—É—á–∏–ª–∏ **${amount}** –≤–∞–ª—é—Ç—ã –æ—Ç <@${senderUser.id}>!`)
      .setColor("#FFD700" as ColorResolvable)
      .setFooter({
          text: `–û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å: ${senderUser.tag}`,
          iconURL: senderUser.displayAvatarURL()
      })
      .setTimestamp();
}

/**
* –°–æ–∑–¥–∞–µ—Ç —ç–º–±–µ–¥ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É–¥–∞–ª–µ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
* @param message –£–¥–∞–ª–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
* @param partNumber –ù–æ–º–µ—Ä —á–∞—Å—Ç–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
* @returns –≠–º–±–µ–¥ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É–¥–∞–ª–µ–Ω–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
*/
export function createDeletedMessageLogEmbed(
  message: Message, 
  partNumber?: number
) {
  const embed = new EmbedBuilder()
      .setTitle(partNumber ? `–°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ (—á–∞—Å—Ç—å ${partNumber})` : "–°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ")
      .setColor("#FF0000" as ColorResolvable)
      .setTimestamp();
  
  if (!partNumber) {
      embed.addFields(
          { name: "–ê–≤—Ç–æ—Ä", value: `${message.author?.tag} (${message.author?.id})`, inline: true },
          { name: "–ö–∞–Ω–∞–ª", value: `<#${message.channelId}> (${message.channelId})`, inline: true },
          { name: "ID —Å–æ–æ–±—â–µ–Ω–∏—è", value: message.id, inline: true }
      );
      
      if (message.attachments.size > 0) {
          const attachmentsList = message.attachments.map(a => `[${a.name}](${a.url})`).join("\n");
          embed.addFields({ name: "–í–ª–æ–∂–µ–Ω–∏—è", value: attachmentsList });
      }
  }
  
  return embed;
}

/**
* –°–æ–∑–¥–∞–µ—Ç —ç–º–±–µ–¥ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
* @param oldMessage –°—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
* @param newMessage –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
* @param contentLabel –ú–µ—Ç–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
* @param partNumber –ù–æ–º–µ—Ä —á–∞—Å—Ç–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
* @returns –≠–º–±–µ–¥ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
*/
export function createEditedMessageLogEmbed(
  oldMessage: Message, 
  newMessage: Message, 
  contentLabel: string,
  partNumber?: number
) {
  const embed = new EmbedBuilder()
      .setTitle(partNumber ? `${contentLabel} (—á–∞—Å—Ç—å ${partNumber})` : "–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ")
      .setColor("#FFA500" as ColorResolvable)
      .setTimestamp();
  
  if (!partNumber) {
      embed.addFields(
          { name: "–ê–≤—Ç–æ—Ä", value: `${newMessage.author?.tag} (${newMessage.author?.id})`, inline: true },
          { name: "–ö–∞–Ω–∞–ª", value: `<#${newMessage.channelId}> (${newMessage.channelId})`, inline: true },
          { name: "ID —Å–æ–æ–±—â–µ–Ω–∏—è", value: newMessage.id, inline: true },
          { name: "–°—Å—ã–ª–∫–∞", value: `[–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é](${newMessage.url})`, inline: true }
      );
  }
  
  return embed;
}

/**
* –°–æ–∑–¥–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —ç–º–±–µ–¥ –¥–ª—è —á–∞—Å—Ç–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
* @param title –ó–∞–≥–æ–ª–æ–≤–æ–∫
* @param content –°–æ–¥–µ—Ä–∂–∏–º–æ–µ
* @param color –¶–≤–µ—Ç (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
* @returns –≠–º–±–µ–¥ —Å —á–∞—Å—Ç—å—é —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
*/
export function createContentPartEmbed(
  title: string, 
  content: string, 
  color: ColorResolvable = "#FFA500"
) {
  return new EmbedBuilder()
      .setTitle(title)
      .setColor(color)
      .setDescription(content);
}


# ./src/utils/userHasAnyRoleFromConfig.ts
import { CommandInteraction, GuildMember } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { Config } from "../entities/Config.js";
import logger from "../services/logger.js";

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ —Ä–æ–ª—å, —É–∫–∞–∑–∞–Ω–Ω–∞—è –≤ –∑–∞–ø–∏—Å—è—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–æ –∫–ª—é—á–∞–º.
 *
 * @param interaction –û–±—ä–µ–∫—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è (CommandInteraction).
 * @param configKeys –ú–∞—Å—Å–∏–≤ –∫–ª—é—á–µ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä ["admin", "high_mod_level"].
 * @returns true, –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ —Ä–æ–ª—å —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –≤ –∫–æ–Ω—Ñ–∏–≥–µ.
 */
export async function userHasAnyRoleFromConfig(
  interaction: CommandInteraction,
  configKeys: string[]
): Promise<boolean> {
  try {
    const configRepository = AppDataSource.getRepository(Config);
    const configs = await configRepository.findBy([
      ...configKeys.map((key) => ({ key }))
    ]);

    if (!configs || configs.length === 0) {
      logger.error(`–ù–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π –ø–æ –∫–ª—é—á–∞–º: ${configKeys.join(", ")}`);
      return false;
    }

    const allowedRoleIds = configs.map((config) => config.value.trim());
    logger.info("–î–æ–ø—É—Å—Ç–∏–º—ã–µ —Ä–æ–ª–∏: %O", allowedRoleIds);

    const member = interaction.member as GuildMember;
    const userRoleIds = member.roles.cache.map((role) => role.id);
    logger.info("–†–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: %O", userRoleIds);

    return userRoleIds.some((roleId) => allowedRoleIds.includes(roleId));
  } catch (error) {
    logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ä–æ–ª–µ–π –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: %O", error);
    return false;
  }
}


# ./src/utils/hoursUtils.ts
/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–∫–ª–æ–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞ "—á–∞—Å" –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º —Ä—É—Å—Å–∫–æ–≥–æ —è–∑—ã–∫–∞
 * @param hours –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å–æ–≤
 * @returns –°—Ç—Ä–æ–∫–∞ —Å–æ —Å–ª–æ–≤–æ–º "—á–∞—Å" –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Å–∫–ª–æ–Ω–µ–Ω–∏–∏
 */
export function getHoursString(hours: number): string {
  const lastDigit = Math.abs(hours) % 10;
  const lastTwoDigits = Math.abs(hours) % 100;

  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return "—á–∞—Å–æ–≤";
  }

  if (lastDigit === 1) {
    return "—á–∞—Å";
  }

  if (lastDigit >= 2 && lastDigit <= 4) {
    return "—á–∞—Å–∞";
  }

  return "—á–∞—Å–æ–≤";
}



# ./src/utils/casinoUtils.ts
import { CasinoResult, CasinoMultiplier } from "../types/casinoTypes.js";

const CASINO_MULTIPLIERS: CasinoMultiplier[] = [
    { 
        chance: 0.005, 
        value: 10.0, 
        emoji: "üíé", 
        description: "–î–ñ–ï–ö–ü–û–¢! –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–∞—è —É–¥–∞—á–∞! –í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ —É–º–Ω–æ–∂–µ–Ω–∞ –≤ 10 —Ä–∞–∑!"
    },
    { 
        chance: 0.045,
        value: 3.0,
        emoji: "üé∞", 
        description: "–ö—Ä—É–ø–Ω—ã–π –≤—ã–∏–≥—Ä—ã—à! –í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ —É–º–Ω–æ–∂–µ–Ω–∞ –≤ 3 —Ä–∞–∑–∞!"
    },
    { 
        chance: 0.15, 
        value: 1.5, 
        emoji: "üçÄ", 
        description: "–ù–µ–ø–ª–æ—Ö–æ–π –≤—ã–∏–≥—Ä—ã—à! –í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ —É–º–Ω–æ–∂–µ–Ω–∞ –≤ 1.5 —Ä–∞–∑–∞."
    },
    { 
        chance: 0.20, 
        value: 1.0, 
        emoji: "üé≤", 
        description: "–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è. –ù–∏ –≤—ã–∏–≥—Ä—ã—à–∞, –Ω–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–∞."
    },
    { 
        chance: 0.60, 
        value: 0, 
        emoji: "üí∏", 
        description: "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É–¥–∞—á–∞ —Å–µ–≥–æ–¥–Ω—è –Ω–µ –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ. –í—ã —Ç–µ—Ä—è–µ—Ç–µ —Å—Ç–∞–≤–∫—É."
    }
];

/**
 * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–≥—Ä—ã –≤ –∫–∞–∑–∏–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ —à–∞–Ω—Å–æ–≤ –≤—ã–ø–∞–¥–µ–Ω–∏—è
 * @returns –†–µ–∑—É–ª—å—Ç–∞—Ç –∏–≥—Ä—ã –≤ –∫–∞–∑–∏–Ω–æ (–º–Ω–æ–∂–∏—Ç–µ–ª—å –∏ –æ–ø–∏—Å–∞–Ω–∏–µ)
 */
export function determineCasinoResult(): CasinoResult {
    const rand = Math.random();
    let cumulativeChance = 0;
    
    for (const multiplier of CASINO_MULTIPLIERS) {
        cumulativeChance += multiplier.chance;
        if (rand <= cumulativeChance) {
            return {
                multiplier: multiplier.value,
                emoji: multiplier.emoji,
                description: multiplier.description
            };
        }
    }
    
    const defaultResult = CASINO_MULTIPLIERS[CASINO_MULTIPLIERS.length - 1];
    return {
        multiplier: defaultResult.value,
        emoji: defaultResult.emoji,
        description: defaultResult.description
    };
}

# ./src/utils/profileImageGenerator.ts
import { createCanvas, loadImage, registerFont, Canvas, CanvasRenderingContext2D, Image } from 'canvas';
import { User } from 'discord.js';
import path from 'path';
import { fileURLToPath } from 'url';
import { isMaxLevel } from './levelUpUtils.js';
import logger from '../services/logger.js';
import { getHoursString } from './hoursUtils.js';
import { getAverageColor } from 'fast-average-color-node';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// -------------------- Font Registration --------------------
/** –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç —à—Ä–∏—Ñ—Ç—ã Montserrat */
function registerFonts(): void {
  try {
    const fontsPath: string = path.join(__dirname, '../../assets/fonts');
    registerFont(path.join(fontsPath, 'Montserrat-Bold.ttf'), { family: 'Montserrat', weight: 'bold' });
    registerFont(path.join(fontsPath, 'Montserrat-Regular.ttf'), { family: 'Montserrat', weight: 'normal' });
  } catch (error: unknown) {
    logger.error('Font registration error:', error);
    throw error;
  }
}

try { registerFonts(); } catch (error: unknown) { logger.error('Font initialization failed:', error); }

// -------------------- Type Definitions --------------------
interface RGB { r: number; g: number; b: number; }
interface HSL { h: number; s: number; l: number; }
interface Styles {
  primary: string;
  secondary: string;
  accent: string;
  text: string;
  textSecondary: string;
  panelBg: string;
  cardBg: string;
  borderRadius: number;
  avatarSize: number;
}

// -------------------- Color Conversion and Analysis --------------------
/**
 * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç RGB –≤ HSL
 */
function rgb2hsl(r: number, g: number, b: number): HSL {
  r /= 255;
  g /= 255;
  b /= 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0, s = 0;
  const l = (max + min) / 2;
  
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    
    h /= 6;
  }
  
  return { h: h * 360, s: s * 100, l: l * 100 };
}

/**
 * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç HSL –≤ RGB
 */
function hsl2rgb(h: number, s: number, l: number): RGB {
  h /= 360;
  s /= 100;
  l /= 100;
  
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

/**
 * –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–æ–º–∏–Ω–∞–Ω—Ç–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤ —Å —É—á–µ—Ç–æ–º –æ–±–ª–∞—Å—Ç–µ–π –∏–Ω—Ç–µ—Ä–µ—Å–∞
 */
async function analyzeImageColors(image: Image): Promise<RGB> {
  try {
    // –°–æ–∑–¥–∞–µ–º Canvas –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    const canvas = createCanvas(image.width, image.height);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0);
    
    let dominantColor: RGB;
    
    try {
      // –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å fast-average-color-node
      // –ù—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å canvas –≤ Buffer –∏–ª–∏ —Å—Ç—Ä–æ–∫—É –¥–ª—è getAverageColor
      const imageBuffer = canvas.toBuffer();
      const fac = await getAverageColor(imageBuffer);
      
      // –¢–µ–ø–µ—Ä—å –ø–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏–∑ —Ç–∏–ø–∞ FastAverageColorResult
      dominantColor = { r: fac.value[0], g: fac.value[1], b: fac.value[2] };
    } catch (facError) {
      logger.warn('Fast average color failed, using fallback method:', facError);
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞—à —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
      dominantColor = computeAverageColor(image);
    }
    
    // –í—ã–±–æ—Ä–æ—á–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ä–∞–∑–Ω—ã—Ö –∑–æ–Ω –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –ª—É—á—à–µ–π –∞–¥–∞–ø—Ç–∞—Ü–∏–∏
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–µ—Ä—Ö–Ω—é—é —á–∞—Å—Ç—å (–≥–¥–µ –±—É–¥–µ—Ç —Ç–µ–∫—Å—Ç)
    const topData = ctx.getImageData(0, 0, canvas.width, Math.floor(canvas.height * 0.3)).data;
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ä–µ–¥–∏–Ω—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const midData = ctx.getImageData(0, Math.floor(canvas.height * 0.3), canvas.width, Math.floor(canvas.height * 0.4)).data;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω–∏–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π
    const topColor = computeAverageFromData(topData);
    const midColor = computeAverageFromData(midData);
    
    // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏, –≥–¥–µ –±—É–¥–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å—Å—è —Ç–µ–∫—Å—Ç
    const r = Math.round((topColor.r * 0.6 + midColor.r * 0.4));
    const g = Math.round((topColor.g * 0.6 + midColor.g * 0.4));
    const b = Math.round((topColor.b * 0.6 + midColor.b * 0.4));
    
    return { r, g, b };
  } catch (error) {
    logger.error('Error analyzing image colors:', error);
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Å–µ—Ä—ã–π —Ü–≤–µ—Ç –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    return { r: 128, g: 128, b: 128 };
  }
}

/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç —Å—Ä–µ–¥–Ω–∏–π —Ü–≤–µ—Ç –∏–∑ –¥–∞–Ω–Ω—ã—Ö ImageData
 */
function computeAverageFromData(data: Uint8ClampedArray): RGB {
  let r = 0, g = 0, b = 0;
  const pixelCount = data.length / 4;
  
  for (let i = 0; i < data.length; i += 4) {
    r += data[i];
    g += data[i + 1];
    b += data[i + 2];
  }
  
  return {
    r: Math.round(r / pixelCount),
    g: Math.round(g / pixelCount),
    b: Math.round(b / pixelCount)
  };
}

/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç —Å—Ä–µ–¥–Ω–∏–π —Ü–≤–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é —É–º–µ–Ω—å—à–µ–Ω–Ω–æ–≥–æ –æ–±—Ä–∞–∑—Ü–∞
 */
function computeAverageColor(image: Image, sampleSize = 50): RGB {
  const offCanvas: Canvas = createCanvas(sampleSize, sampleSize);
  const offCtx: CanvasRenderingContext2D = offCanvas.getContext('2d')!;
  offCtx.drawImage(image, 0, 0, sampleSize, sampleSize);
  const data = offCtx.getImageData(0, 0, sampleSize, sampleSize).data;
  let r = 0, g = 0, b = 0;
  const count = data.length / 4;
  for (let i = 0; i < data.length; i += 4) {
    r += data[i];
    g += data[i + 1];
    b += data[i + 2];
  }
  return { r: Math.round(r / count), g: Math.round(g / count), b: Math.round(b / count) };
}

/**
 * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ü–≤–µ—Ç —Å–ª–∏—à–∫–æ–º —Ç–µ–º–Ω—ã–º –∏–ª–∏ —Å–ª–∏—à–∫–æ–º —Å–≤–µ—Ç–ª—ã–º
 */
function isColorExtreme(color: RGB): boolean {
  const brightness = (color.r * 299 + color.g * 587 + color.b * 114) / 1000;
  return brightness < 30 || brightness > 225;
}

/**
 * –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç —Ü–≤–µ—Ç, –µ—Å–ª–∏ –æ–Ω —Å–ª–∏—à–∫–æ–º —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–π
 */
function normalizeColor(color: RGB): RGB {
  const brightness = (color.r * 299 + color.g * 587 + color.b * 114) / 1000;
  
  if (brightness < 30) {
    // –°–ª–∏—à–∫–æ–º —Ç–µ–º–Ω—ã–π —Ü–≤–µ—Ç, –¥–µ–ª–∞–µ–º –µ–≥–æ —Å–≤–µ—Ç–ª–µ–µ
    const hsl = rgb2hsl(color.r, color.g, color.b);
    hsl.l = Math.max(hsl.l, 20); // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å 20%
    return hsl2rgb(hsl.h, hsl.s, hsl.l);
  } else if (brightness > 225) {
    // –°–ª–∏—à–∫–æ–º —Å–≤–µ—Ç–ª—ã–π —Ü–≤–µ—Ç, –¥–µ–ª–∞–µ–º –µ–≥–æ —Ç–µ–º–Ω–µ–µ
    const hsl = rgb2hsl(color.r, color.g, color.b);
    hsl.l = Math.min(hsl.l, 80); // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å 80%
    return hsl2rgb(hsl.h, hsl.s, hsl.l);
  }
  
  return color;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç–∏–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∞–∑–æ–≤–æ–≥–æ —Ü–≤–µ—Ç–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π
 */
function generateStylesFromColor(color: RGB): Styles {
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ü–≤–µ—Ç –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
  const normalizedColor = normalizeColor(color);
  const { r, g, b } = normalizedColor;
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ HSL –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–π –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ —Ü–≤–µ—Ç–∞–º–∏
  const hsl = rgb2hsl(r, g, b);
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–≤–µ—Ç–ª–æ—Ç—É –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
  const isDark = hsl.l < 50;
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–æ–Ω–∞
  const textColor = isDark ? '#FFFFFF' : '#000000';
  const textSecondary = isDark ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.7)';
  
  // –°–æ–∑–¥–∞–µ–º –≤–∞—Ä–∏–∞—Ü–∏–∏ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ —Å —Ä–∞–∑–Ω–æ–π –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å—é –∏ —è—Ä–∫–æ—Å—Ç—å—é
  const primary = hslToString(hsl.h, Math.min(hsl.s + 10, 100), isDark ? Math.min(hsl.l + 15, 90) : Math.max(hsl.l - 15, 10));
  const secondary = hslToString(hsl.h, Math.min(hsl.s + 5, 100), isDark ? Math.min(hsl.l + 5, 85) : Math.max(hsl.l - 5, 15));
  
  // –°–æ–∑–¥–∞–µ–º –∞–∫—Ü–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç, —Å–º–µ—â–∞—è –æ—Ç—Ç–µ–Ω–æ–∫
  const accentHue = (hsl.h + 180) % 360; // –ö–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π —Ü–≤–µ—Ç
  const accent = hslToString(accentHue, Math.min(70, hsl.s + 20), isDark ? 65 : 45);
  
  // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ —Ñ–æ–Ω—ã –¥–ª—è –ø–∞–Ω–µ–ª–µ–π —Å –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
  const panelBg = isDark 
    ? `rgba(${Math.floor(r/3)}, ${Math.floor(g/3)}, ${Math.floor(b/3)}, 0.75)` 
    : `rgba(${Math.min(r+20, 255)}, ${Math.min(g+20, 255)}, ${Math.min(b+20, 255)}, 0.75)`;
  
  const cardBg = isDark
    ? `rgba(${Math.floor(r/4)}, ${Math.floor(g/4)}, ${Math.floor(b/4)}, 0.8)`  
    : `rgba(${Math.min(r+30, 255)}, ${Math.min(g+30, 255)}, ${Math.min(b+30, 255)}, 0.75)`;
  
  return {
    primary,
    secondary,
    accent,
    text: textColor,
    textSecondary,
    panelBg,
    cardBg,
    borderRadius: 15,
    avatarSize: 160,
  };
}

/**
 * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç HSL –≤ —Å—Ç—Ä–æ–∫—É CSS
 */
function hslToString(h: number, s: number, l: number): string {
  return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
}

// -------------------- Polyfill for roundRect --------------------
const ctxPrototype = Object.getPrototypeOf(createCanvas(1,1).getContext('2d')) as any;
if (!ctxPrototype.roundRect) {
  ctxPrototype.roundRect = function(x: number,y: number,w: number,h: number,r: number) {
    if (r > w/2) r = w/2; if (r > h/2) r = h/2;
    this.beginPath(); this.moveTo(x+r,y);
    this.arcTo(x+w,y,x+w,y+h,r);
    this.arcTo(x+w,y+h,x,y+h,r);
    this.arcTo(x,y+h,x,y,r);
    this.arcTo(x,y,x+w,y,r);
    this.closePath(); return this;
  };
}

export async function generateProfileImage(
  user: User,
  messageCount: number,
  voiceMinutes: number,
  level: number,
  currency: number,
  progressPercent: number,
  backgroundImagePath?: string // –î–æ–±–∞–≤–ª—è–µ–º –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –ø—É—Ç–∏ –∫ –∫–∞—Å—Ç–æ–º–Ω–æ–º—É —Ñ–æ–Ω—É
): Promise<Buffer> {
  try {
    const canvas: Canvas = createCanvas(1000, 500);
    const ctx: CanvasRenderingContext2D = canvas.getContext('2d')!;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ
    const bgPath = backgroundImagePath || path.join(__dirname, '../../assets/images/marmok_background.png');
    const bgImage: Image = await loadImage(bgPath) as Image;
    
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ü–≤–µ—Ç–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º
    const avgColor = await analyzeImageColors(bgImage);
    const styles = generateStylesFromColor(avgColor);
    
    // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ñ–æ–Ω —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ–º
    await drawBackground(ctx, canvas, bgImage, styles);
    
    const voiceHours = Math.floor(voiceMinutes/60);
    const hoursString = getHoursString(voiceHours);
    
    await drawProfileHeader(ctx, user, styles);
    drawStatisticsPanel(ctx, messageCount, voiceHours, hoursString, currency, styles);
    drawLevelPanel(ctx, level, progressPercent, styles);
    
    return canvas.toBuffer();
  } catch (error: unknown) {
    logger.error('Error generating profile image:', error);
    return createErrorCanvas();
  }
}

function createErrorCanvas(): Buffer {
  const canvas: Canvas = createCanvas(800, 400);
  const ctx: CanvasRenderingContext2D = canvas.getContext('2d')!;
  ctx.fillStyle = '#1E1E1E';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.font = 'bold 32px Montserrat';
  ctx.fillStyle = '#FF6B00';
  ctx.textAlign = 'center';
  ctx.fillText('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è', canvas.width/2, canvas.height/2);
  return canvas.toBuffer();
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç —Ñ–æ–Ω —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–≤–µ—Ç–æ–≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
 */
async function drawBackground(
  ctx: CanvasRenderingContext2D,
  canvas: Canvas,
  bgImage: Image,
  styles: Styles
): Promise<void> {
  // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ–≥–æ —Ö–æ–ª—Å—Ç–∞
  const scale = Math.max(canvas.width / bgImage.width, canvas.height / bgImage.height);
  const scaledWidth = bgImage.width * scale;
  const scaledHeight = bgImage.height * scale;
  const x = (canvas.width - scaledWidth) / 2;
  const y = (canvas.height - scaledHeight) / 2;
  
  // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
  ctx.drawImage(bgImage, x, y, scaledWidth, scaledHeight);
  
  // –ü–æ–ª—É—á–∞–µ–º —Å—Ä–µ–¥–Ω–∏–π —Ü–≤–µ—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —è—Ä–∫–æ—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞ –∏–∑ styles –≤–º–µ—Å—Ç–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
  // –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–∏–º–µ—Ä–Ω—ã–µ RGB –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏ CSS primary
  const styleColorMatch = styles.primary.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
  let r = 128, g = 128, b = 128;
  let hsl: HSL;
  
  if (styleColorMatch && styleColorMatch.length >= 4) {
    // –ï—Å–ª–∏ primary –≤ —Ñ–æ—Ä–º–∞—Ç–µ HSL, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ RGB
    const h = parseInt(styleColorMatch[1], 10);
    const s = parseInt(styleColorMatch[2], 10);
    const l = parseInt(styleColorMatch[3], 10);
    hsl = { h, s, l };
    const rgb = hsl2rgb(h, s, l);
    r = rgb.r;
    g = rgb.g;
    b = rgb.b;
  } else {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ —Ü–≤–µ—Ç–∞ –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const sampleColor = computeAverageColor(bgImage);
    r = sampleColor.r;
    g = sampleColor.g;
    b = sampleColor.b;
    hsl = rgb2hsl(r, g, b);
  }
  
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  const isDark = brightness < 128;
  
  // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –∑–∞—Ç–µ–º–Ω–µ–Ω–∏—è (—Ç–µ–º–Ω–µ–µ —Å–≤–µ—Ä—Ö—É, —Å–≤–µ—Ç–ª–µ–µ —Å–Ω–∏–∑—É)
  // –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ª—É—á—à—É—é –≤–∏–¥–∏–º–æ—Å—Ç—å —Ç–µ–∫—Å—Ç–∞ –ø—Ä–æ—Ñ–∏–ª—è –≤ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏
  const overlayGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  
  if (isDark) {
    // –î–ª—è —Ç–µ–º–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–µ–ª–∞–µ–º –º–µ–Ω–µ–µ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ
    overlayGradient.addColorStop(0, `rgba(0, 0, 0, 0.7)`);
    overlayGradient.addColorStop(0.4, `rgba(0, 0, 0, 0.6)`);
    overlayGradient.addColorStop(1, `rgba(0, 0, 0, 0.4)`);
  } else {
    // –î–ª—è —Å–≤–µ—Ç–ª—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–µ–ª–∞–µ–º –±–æ–ª–µ–µ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ
    overlayGradient.addColorStop(0, `rgba(0, 0, 0, 0.8)`);
    overlayGradient.addColorStop(0.4, `rgba(0, 0, 0, 0.7)`);
    overlayGradient.addColorStop(1, `rgba(0, 0, 0, 0.5)`);
  }
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ
  ctx.fillStyle = overlayGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Ü–≤–µ—Ç–Ω–æ–π –æ–≤–µ—Ä–ª–µ–π, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ü–≤–µ—Ç–æ–≤–æ–π –≥–∞–º–º–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
  const colorOverlay = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  
  // –°–æ–∑–¥–∞–µ–º –±–æ–ª–µ–µ –Ω–∞—Å—ã—â–µ–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é –±–∞–∑–æ–≤–æ–≥–æ —Ü–≤–µ—Ç–∞
  const saturatedHSL = {
    h: hsl.h,
    s: Math.min(hsl.s + 10, 100),
    l: isDark ? Math.min(hsl.l + 10, 50) : Math.max(hsl.l - 10, 30)
  };
  
  // –î–æ–±–∞–≤–ª—è–µ–º –∞–∫—Ü–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç (–∫–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π –æ—Ç—Ç–µ–Ω–æ–∫)
  const accentHSL = {
    h: (hsl.h + 30) % 360, // –°–ª–µ–≥–∫–∞ —Å–º–µ—â–∞–µ–º –æ—Ç—Ç–µ–Ω–æ–∫
    s: saturatedHSL.s,
    l: saturatedHSL.l
  };
  
  // –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç —Å –æ—Ç—Ç–µ–Ω–∫–æ–º –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
  const rgbMain = hsl2rgb(saturatedHSL.h, saturatedHSL.s, saturatedHSL.l);
  const rgbAccent = hsl2rgb(accentHSL.h, accentHSL.s, accentHSL.l);
  
  colorOverlay.addColorStop(0, `rgba(${rgbMain.r}, ${rgbMain.g}, ${rgbMain.b}, 0.3)`);
  colorOverlay.addColorStop(1, `rgba(${rgbAccent.r}, ${rgbAccent.g}, ${rgbAccent.b}, 0.2)`);
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç–Ω–æ–π –æ–≤–µ—Ä–ª–µ–π
  ctx.fillStyle = colorOverlay;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–Ω—å–µ—Ç–∫—É –ø–æ –∫—Ä–∞—è–º –¥–ª—è –ª—É—á—à–µ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
  const vignette = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
    canvas.width / 2, canvas.height / 2, canvas.width * 0.7
  );
  vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vignette.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
  
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –≤–µ—Ä—Ö–Ω—é—é —á–∞—Å—Ç—å –ø—Ä–æ—Ñ–∏–ª—è —Å –∞–≤–∞—Ç–∞—Ä–æ–º –∏ –∏–º–µ–Ω–µ–º
 */
async function drawProfileHeader(ctx: any, user: User, styles: any) {
  try {
    const avatarX = 70;
    const avatarY = 70;
    const avatarSize = styles.avatarSize;
    const avatarURL = user.displayAvatarURL({ extension: 'png', size: 512 }) || user.defaultAvatarURL;
    const avatar = await loadImage(avatarURL);

    // –†–∏—Å—É–µ–º –∞–≤–∞—Ç–∞—Ä —Å —Ç–µ–Ω—å—é
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 15;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 4;
    ctx.beginPath();
    ctx.arc(avatarX + avatarSize / 2, avatarY + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
    ctx.clip();
    ctx.drawImage(avatar, avatarX, avatarY, avatarSize, avatarSize);
    ctx.restore();

    // –†–∏—Å—É–µ–º –æ–±–≤–æ–¥–∫—É –∞–≤–∞—Ç–∞—Ä–∞
    ctx.beginPath();
    ctx.arc(avatarX + avatarSize / 2, avatarY + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
    ctx.strokeStyle = styles.primary;
    ctx.lineWidth = 5;
    ctx.stroke();

    // –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç—å—é
    ctx.save();
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ –Ω–∞ –ª—é–±–æ–º —Ñ–æ–Ω–µ
    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    
    ctx.font = 'bold 42px Montserrat';
    ctx.fillStyle = styles.text;
    ctx.textAlign = 'left';
    ctx.fillText(user.username, avatarX + avatarSize + 40, avatarY + 60);

    // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å —Ç–µ–Ω—å—é –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    ctx.font = '24px Montserrat';
    ctx.fillStyle = styles.accent;
    ctx.fillText(`ID: ${user.id}`, avatarX + avatarSize + 40, avatarY + 100);
    ctx.restore();

    // –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ –æ—Ç—Ä–∏—Å–æ–≤–∞—Ç—å, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–∏–∂–µ)
  } catch (error) {
    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞: ${error}`);
    drawFallbackAvatar(ctx, 70, 70, styles);
  }
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –∑–∞–ø–∞—Å–Ω–æ–π –∞–≤–∞—Ç–∞—Ä –ø—Ä–∏ –æ—à–∏–±–∫–µ –∑–∞–≥—Ä—É–∑–∫–∏
 */
function drawFallbackAvatar(ctx: any, x: number, y: number, styles: any) {
  const size = styles.avatarSize;
  ctx.fillStyle = styles.primary;
  ctx.beginPath();
  ctx.arc(x + size / 2, y + size / 2, size / 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = styles.text;
  ctx.font = 'bold 60px Montserrat';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('?', x + size / 2, y + size / 2);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

/**
 * –†–∏—Å—É–µ—Ç –ø–∞–Ω–µ–ª—å —Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ —É–≥–ª–∞–º–∏ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
 */
function drawPanel(ctx: any, x: number, y: number, width: number, height: number, radius: number, styles: any) {
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≥–ª—É–±–∏–Ω—ã
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 3;
  
  // –§–æ–Ω –ø–∞–Ω–µ–ª–∏ —Å –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
  const panelBgAlpha = styles.panelBg.match(/rgba\(.*,\s*([\d\.]+)\)/);
  let panelBgColor;
  
  if (panelBgAlpha && panelBgAlpha[1]) {
    // –ï—Å–ª–∏ panelBg —É–∂–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ rgba, —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
    const currentAlpha = parseFloat(panelBgAlpha[1]);
    const newAlpha = Math.max(0.5, currentAlpha * 0.85); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞ 15%
    panelBgColor = styles.panelBg.replace(/rgba\(.*,\s*[\d\.]+\)/, `rgba/**
 * –†–∏—Å—É–µ—Ç –ø–∞–Ω–µ–ª—å —Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ —É–≥–ª–∞–º–∏ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
 */
function drawPanel(ctx: any, x: number, y: number, width: number, height: number, radius: number, styles: any) {
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≥–ª—É–±–∏–Ω—ã
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 3;
  
  // –§–æ–Ω –ø–∞–Ω–µ–ª–∏
  ctx.fillStyle = styles.panelBg;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.fill();
  ctx.restore();
  
  // –û–±–≤–æ–¥–∫–∞ –ø–∞–Ω–µ–ª–∏ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
  const strokeGradient = ctx.createLinearGradient(x, y, x + width, y + height);
  strokeGradient.addColorStop(0, styles.primary);
  strokeGradient.addColorStop(1, styles.secondary);
  
  ctx.strokeStyle = strokeGradient;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.stroke();
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ –≤–µ—Ä—Ö–Ω–µ–º—É –∫—Ä–∞—é –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
  const glowGradient = ctx.createLinearGradient(x, y, x, y + height * 0.1);
  glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
  glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  
  ctx.fillStyle = glowGradient;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height * 0.1, radius);
  ctx.fill();
}`.replace(/,\s*[\d\.]+\)$/, `, ${newAlpha})`));
  } else if (styles.panelBg.startsWith('rgb(')) {
    // –ï—Å–ª–∏ panelBg –≤ —Ñ–æ—Ä–º–∞—Ç–µ rgb, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ rgba
    panelBgColor = styles.panelBg.replace(/rgb\((.*)\)/, `rgba($1, 0.8)`);
  } else {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω
    panelBgColor = styles.panelBg;
  }
  
  ctx.fillStyle = panelBgColor;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.fill();
  ctx.restore();
  
  // –û–±–≤–æ–¥–∫–∞ –ø–∞–Ω–µ–ª–∏ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
  const strokeGradient = ctx.createLinearGradient(x, y, x + width, y + height);
  strokeGradient.addColorStop(0, styles.primary);
  strokeGradient.addColorStop(1, styles.secondary);
  
  ctx.strokeStyle = strokeGradient;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.stroke();
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ –≤–µ—Ä—Ö–Ω–µ–º—É –∫—Ä–∞—é –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
  const glowGradient = ctx.createLinearGradient(x, y, x, y + height * 0.1);
  glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
  glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  
  ctx.fillStyle = glowGradient;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height * 0.1, radius);
  ctx.fill();
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –ø–∞–Ω–µ–ª—å —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
 */
function drawStatisticsPanel(
  ctx: any, 
  messageCount: number, 
  voiceHours: number, 
  hoursString: string, 
  currency: number, 
  styles: any
) {
  const panelX = 60;
  const panelY = 250;
  const panelWidth = 420;
  const panelHeight = 200;

  drawPanel(ctx, panelX, panelY, panelWidth, panelHeight, styles.borderRadius, styles);
  
  // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–µ–ª–∏ —Å —Ç–µ–Ω—å—é –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 1;
  
  ctx.font = 'bold 28px Montserrat';
  ctx.fillStyle = styles.primary;
  ctx.textAlign = 'left';
  ctx.fillText('–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', panelX + 25, panelY + 40);
  ctx.restore();
  
  drawStatItem(ctx, panelX + 25, panelY + 90, `–°–æ–æ–±—â–µ–Ω–∏–π: ${messageCount.toLocaleString('ru-RU')}`, styles);
  drawStatItem(ctx, panelX + 25, panelY + 130, `–í –≥–æ–ª–æ—Å–æ–≤—ã—Ö: ${voiceHours} ${hoursString}`, styles);
  drawStatItem(ctx, panelX + 25, panelY + 170, `–ë–∞–ª–∞–Ω—Å: ${currency.toLocaleString('ru-RU')} $`, styles);
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å –∏–∫–æ–Ω–∫–æ–π
 */
function drawStatItem(ctx: any, x: number, y: number, text: string, styles: any) {
  ctx.save();
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è —Ç–µ–∫—Å—Ç–∞
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 3;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 1;
  const textOnPanel = 'rgba(255, 255, 255, 0.95)';

    
  // –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç
  ctx.font = '24px Montserrat';
  ctx.fillStyle = textOnPanel;
  ctx.fillText(text, x, y);
  ctx.restore();
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –ø–∞–Ω–µ–ª—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É—Ä–æ–≤–Ω–µ, –≤–∫–ª—é—á–∞—è –∫—Ä—É–≥ —Å —É—Ä–æ–≤–Ω–µ–º –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
 */
function drawLevelPanel(
  ctx: any, 
  level: number, 
  progressPercent: number, 
  styles: any
) {
  const panelX = 520;
  const panelY = 250;
  const panelWidth = 420;
  const panelHeight = 200;
  
  drawPanel(ctx, panelX, panelY, panelWidth, panelHeight, styles.borderRadius, styles);
  
  // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–µ–ª–∏ "–£—Ä–æ–≤–µ–Ω—å" —Å —Ç–µ–Ω—å—é –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 1;
  
  ctx.font = 'bold 28px Montserrat';
  ctx.fillStyle = styles.primary;
  ctx.textAlign = 'left';
  ctx.fillText('–£—Ä–æ–≤–µ–Ω—å', panelX + 25, panelY + 40);
  ctx.restore();
  
  // –§–æ–Ω–æ–≤—ã–π –∫—Ä—É–≥ –¥–ª—è —É—Ä–æ–≤–Ω—è —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Å–≤–µ—á–µ–Ω–∏—è
  const circleX = panelX + 90;
  const circleY = panelY + 120;
  const circleRadius = 60;
  
  // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è / –æ—Ä–µ–æ–ª–∞ –≤–æ–∫—Ä—É–≥ –∫—Ä—É–≥–∞
  const glowRadius = circleRadius + 10;
  const glowGradient = ctx.createRadialGradient(
    circleX, circleY, circleRadius - 10,
    circleX, circleY, glowRadius
  );
  glowGradient.addColorStop(0, `${styles.primary}80`); // 50% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
  glowGradient.addColorStop(1, `${styles.primary}00`); // 0% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
  
  ctx.fillStyle = glowGradient;
  ctx.beginPath();
  ctx.arc(circleX, circleY, glowRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // –§–æ–Ω –∫—Ä—É–≥–∞ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
  const circleGradient = ctx.createRadialGradient(
    circleX - circleRadius/3, circleY - circleRadius/3, 0,
    circleX, circleY, circleRadius
  );
  circleGradient.addColorStop(0, styles.cardBg);
  circleGradient.addColorStop(1, styles.panelBg);
  
  ctx.fillStyle = circleGradient;
  ctx.beginPath();
  ctx.arc(circleX, circleY, circleRadius, 0, Math.PI * 2);
  ctx.fill();

  // –û–±–≤–æ–¥–∫–∞ –∫—Ä—É–≥–∞
  ctx.save();
  ctx.strokeStyle = styles.primary;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(circleX, circleY, circleRadius, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
  
  // –£—Ä–æ–≤–µ–Ω—å –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞ —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Ç–µ–Ω–∏ –¥–ª—è –æ–±—ä–µ–º–∞
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
  ctx.shadowBlur = 5;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  
  ctx.font = 'bold 48px Montserrat';
  ctx.fillStyle = styles.primary;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(level.toString(), circleX, circleY);
  ctx.restore();
  
  // –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –¥–∏–∑–∞–π–Ω–æ–º
  if (!isMaxLevel(level)) {
    const barX = panelX + 190;
    const barY = panelY + 120;
    const barWidth = 200;
    const barHeight = 20;
    const barRadius = 10;
    
    // –≠—Ñ—Ñ–µ–∫—Ç —Ç–µ–Ω–∏ –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    
    // –§–æ–Ω –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
    const barBgGradient = ctx.createLinearGradient(barX, 0, barX + barWidth, 0);
    barBgGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
    barBgGradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
    
    ctx.fillStyle = barBgGradient;
    ctx.beginPath();
    ctx.roundRect(barX, barY, barWidth, barHeight, barRadius);
    ctx.fill();
    ctx.restore();
    
    // –ó–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è —á–∞—Å—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
    const clampedProgress = Math.max(0, Math.min(progressPercent, 100));
    let progressWidth = Math.max(barHeight, barWidth * clampedProgress / 100); // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ = –≤—ã—Å–æ—Ç–∞ –±–∞—Ä–∞
    
    // –î–ª—è –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–µ–ª–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ –∑–∞–º–µ—Ç–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å
    if (clampedProgress > 0 && progressWidth < barHeight * 2) {
      progressWidth = barHeight * 1.2; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤–∏–¥–∏–º–∞—è —à–∏—Ä–∏–Ω–∞
    }
    
    // –°–æ–∑–¥–∞–µ–º –∫—Ä–∞—Å–∏–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
    const gradient = ctx.createLinearGradient(barX, 0, barX + barWidth, 0);
    gradient.addColorStop(0, styles.primary);
    gradient.addColorStop(0.5, styles.accent);
    gradient.addColorStop(1, styles.secondary);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.roundRect(barX, barY, progressWidth, barHeight, barRadius);
    ctx.fill();
    
    // –≠—Ñ—Ñ–µ–∫—Ç –±–ª–∏–∫–∞ –Ω–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–µ –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
    const shineGradient = ctx.createLinearGradient(barX, barY, barX, barY + barHeight/2);
    shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
    shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = shineGradient;
    ctx.beginPath();
    ctx.roundRect(barX, barY, progressWidth, barHeight/2, barRadius);
    ctx.fill();
    
    // –¢–µ–∫—Å—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å —Ç–µ–Ω—å—é –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 3;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    
    ctx.font = 'bold 18px Montserrat';
    ctx.fillStyle = styles.text;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${clampedProgress}%`, barX + barWidth / 2, barY - 5);
    ctx.restore();
  } else {
    // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å —Å –≤–∏–∑—É–∞–ª—å–Ω—ã–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º
    ctx.save();
    // –°–æ–∑–¥–∞–µ–º –ø—É–ª—å—Å–∏—Ä—É—é—â–∏–π —ç—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è
    ctx.shadowColor = styles.accent;
    ctx.shadowBlur = 15;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    // –†–∞–∑–º–µ—â–∞–µ–º —Ç–µ–∫—Å—Ç "–ú–ê–ö–°. –£–†–û–í–ï–ù–¨" –ø–æ —Ü–µ–Ω—Ç—Ä—É –≤—Ç–æ—Ä–æ–π –ø–∞–Ω–µ–ª–∏ –∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫—Ä—É–∂–∫–∞
    const maxLevelTextX = panelX + (panelWidth - circleRadius * 2) - 10; // –°–º–µ—â–∞–µ–º –≤–ø—Ä–∞–≤–æ –æ—Ç —Å–µ—Ä–µ–¥–∏–Ω—ã –ø–∞–Ω–µ–ª–∏
    const maxLevelTextY = panelY + 120;
    
    ctx.font = 'bold 22px Montserrat';
    ctx.fillStyle = styles.accent;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('–ú–ê–ö–°. –£–†–û–í–ï–ù–¨', maxLevelTextX, maxLevelTextY);
    ctx.restore();
    
    // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∑–≤–µ–∑–¥–æ—á–∫–∏ –∏–ª–∏ –∏—Å–∫—Ä—ã –≤–æ–∫—Ä—É–≥ —Ç–µ–∫—Å—Ç–∞
    const sparklePoints = [
      {x: maxLevelTextX - 100, y: maxLevelTextY - 10},
      {x: maxLevelTextX + 100, y: maxLevelTextY - 10},
      {x: maxLevelTextX - 100, y: maxLevelTextY + 10},
      {x: maxLevelTextX + 100, y: maxLevelTextY + 10}
    ];
    
    sparklePoints.forEach(point => {
      drawSpark(ctx, point.x, point.y, 5, styles.accent);
    });
  }
}

/**
 * –†–∏—Å—É–µ—Ç –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—É—é –∏—Å–∫—Ä—É –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è
 */
function drawSpark(ctx: any, x: number, y: number, size: number, color: string): void {
  ctx.save();
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 10;
  
  // –†–∏—Å—É–µ–º —á–µ—Ç—ã—Ä–µ—Ö–∫–æ–Ω–µ—á–Ω—É—é –∑–≤–µ–∑–¥—É
  ctx.beginPath();
  ctx.moveTo(x, y - size);
  ctx.lineTo(x + size/4, y - size/4);
  ctx.lineTo(x + size, y);
  ctx.lineTo(x + size/4, y + size/4);
  ctx.lineTo(x, y + size);
  ctx.lineTo(x - size/4, y + size/4);
  ctx.lineTo(x - size, y);
  ctx.lineTo(x - size/4, y - size/4);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

# ./src/utils/giftUtils.ts
import { GiftReward, GIFT_TYPES } from "../types/giftTypes.js";

/**
 * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ–¥–∏–Ω –ø–æ–¥–∞—Ä–æ–∫ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –Ω–∞–≥—Ä–∞–¥—É
 * –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —à–∞–Ω—Å—ã —Å –º–µ–Ω—å—à–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥
 */
export function openGift(): GiftReward {
    const random = Math.random();
    let cumulativeChance = 0;
    

    for (const item of GIFT_TYPES) {
        cumulativeChance += item.chance;
        if (random <= cumulativeChance) {
            const reward = { ...item.reward };
            
            if (reward.type === 'currency') {
                switch (reward.rarity) {
                    case 'common':
                        reward.amount = getRandomInt(50, 150);
                        break;
                    case 'uncommon':
                        reward.amount = getRandomInt(200, 400);
                        break;
                    case 'rare':
                        reward.amount = getRandomInt(450, 700);
                        break;
                    case 'legendary':
                        reward.amount = getRandomInt(750, 1200);
                        break;
                }
            }
            
            return reward;
        }
    }
    
    return GIFT_TYPES[0].reward;
}

/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –≤ –∑–∞–¥–∞–Ω–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ (–≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ)
 */
export function getRandomInt(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

export function pluralizeGifts(count: number): string {
    if ([2, 3, 4].includes(count % 10) && ![12, 13, 14].includes(count % 100)) return '–ø–æ–¥–∞—Ä–∫–∞';
    return '–ø–æ–¥–∞—Ä–∫–æ–≤';
  }

# ./src/utils/drawSkillTree.ts.old
import { createCanvas, loadImage, registerFont } from 'canvas';
import type { Canvas, CanvasRenderingContext2D } from 'canvas';
import path from 'path';
import { fileURLToPath } from 'url';
import logger from '../services/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// -------------------- Font Registration --------------------
/** –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç —à—Ä–∏—Ñ—Ç—ã Montserrat */
function registerFonts(): void {
  try {
    const fontsPath = path.join(__dirname, '../../assets/fonts');
    registerFont(path.join(fontsPath, 'Montserrat-Bold.ttf'), { family: 'Montserrat', weight: 'bold' });
    registerFont(path.join(fontsPath, 'Montserrat-Regular.ttf'), { family: 'Montserrat', weight: 'normal' });
  } catch (error: unknown) {
    logger.error('Font registration error:', error);
    throw error;
  }
}

try { registerFonts(); } catch (error: unknown) { logger.error('Font initialization failed:', error); }

// -------------------- Type Definitions --------------------
interface RGB { r: number; g: number; b: number; }
interface HSL { h: number; s: number; l: number; }
interface Styles {
  primary: string;
  secondary: string;
  accent: string;
  text: string;
  textSecondary: string;
  panelBg: string;
  cardBg: string;
  borderRadius: number;
  avatarSize: number;
}

/**
 * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–∞–≤—ã–∫–∞
 */
interface Skill {
    id: string;
    name: string;
    level: number;
    maxLevel: number;
    icon?: string; // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø—É—Ç—å –∫ –∑–Ω–∞—á–∫—É –Ω–∞–≤—ã–∫–∞
    description?: string;
    unlocked: boolean;
    requiredLevel?: number; // –î–æ–±–∞–≤–ª–µ–Ω–æ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è —Ç—Ä–µ–±—É–µ–º–æ–≥–æ —É—Ä–æ–≤–Ω—è
    position: { x: number; y: number }; // –ü–æ–∑–∏—Ü–∏—è –Ω–∞ –¥–µ—Ä–µ–≤–µ
    connections: string[]; // ID –Ω–∞–≤—ã–∫–æ–≤, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –µ—Å—Ç—å —Å–≤—è–∑—å
  }

// -------------------- Color Conversion and Analysis --------------------
/**
 * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç RGB –≤ HSL
 */
function rgb2hsl(r: number, g: number, b: number): HSL {
  r /= 255;
  g /= 255;
  b /= 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0, s = 0;
  const l = (max + min) / 2;
  
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    
    h /= 6;
  }
  
  return { h: h * 360, s: s * 100, l: l * 100 };
}

/**
 * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç HSL –≤ RGB
 */
function hsl2rgb(h: number, s: number, l: number): RGB {
  h /= 360;
  s /= 100;
  l /= 100;
  
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

/**
 * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç HSL –≤ —Å—Ç—Ä–æ–∫—É CSS
 */
function hslToString(h: number, s: number, l: number): string {
  return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
}

/**
 * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ü–≤–µ—Ç —Å–ª–∏—à–∫–æ–º —Ç–µ–º–Ω—ã–º –∏–ª–∏ —Å–ª–∏—à–∫–æ–º —Å–≤–µ—Ç–ª—ã–º
 */
function isColorExtreme(color: RGB): boolean {
  const brightness = (color.r * 299 + color.g * 587 + color.b * 114) / 1000;
  return brightness < 30 || brightness > 225;
}

/**
 * –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç —Ü–≤–µ—Ç, –µ—Å–ª–∏ –æ–Ω —Å–ª–∏—à–∫–æ–º —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–π
 */
function normalizeColor(color: RGB): RGB {
  const brightness = (color.r * 299 + color.g * 587 + color.b * 114) / 1000;
  
  if (brightness < 30) {
    // –°–ª–∏—à–∫–æ–º —Ç–µ–º–Ω—ã–π —Ü–≤–µ—Ç, –¥–µ–ª–∞–µ–º –µ–≥–æ —Å–≤–µ—Ç–ª–µ–µ
    const hsl = rgb2hsl(color.r, color.g, color.b);
    hsl.l = Math.max(hsl.l, 20); // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å 20%
    return hsl2rgb(hsl.h, hsl.s, hsl.l);
  } else if (brightness > 225) {
    // –°–ª–∏—à–∫–æ–º —Å–≤–µ—Ç–ª—ã–π —Ü–≤–µ—Ç, –¥–µ–ª–∞–µ–º –µ–≥–æ —Ç–µ–º–Ω–µ–µ
    const hsl = rgb2hsl(color.r, color.g, color.b);
    hsl.l = Math.min(hsl.l, 80); // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å 80%
    return hsl2rgb(hsl.h, hsl.s, hsl.l);
  }
  
  return color;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç–∏–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∞–∑–æ–≤–æ–≥–æ —Ü–≤–µ—Ç–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π
 */
function generateStylesFromColor(color: RGB): Styles {
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ü–≤–µ—Ç –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
  const normalizedColor = normalizeColor(color);
  const { r, g, b } = normalizedColor;
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ HSL –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–π –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ —Ü–≤–µ—Ç–∞–º–∏
  const hsl = rgb2hsl(r, g, b);
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–≤–µ—Ç–ª–æ—Ç—É –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
  const isDark = hsl.l < 50;
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–æ–Ω–∞
  const textColor = isDark ? '#FFFFFF' : '#000000';
  const textSecondary = isDark ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.7)';
  
  // –°–æ–∑–¥–∞–µ–º –≤–∞—Ä–∏–∞—Ü–∏–∏ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ —Å —Ä–∞–∑–Ω–æ–π –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å—é –∏ —è—Ä–∫–æ—Å—Ç—å—é
  const primary = hslToString(hsl.h, Math.min(hsl.s + 10, 100), isDark ? Math.min(hsl.l + 15, 90) : Math.max(hsl.l - 15, 10));
  const secondary = hslToString(hsl.h, Math.min(hsl.s + 5, 100), isDark ? Math.min(hsl.l + 5, 85) : Math.max(hsl.l - 5, 15));
  
  // –°–æ–∑–¥–∞–µ–º –∞–∫—Ü–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç, —Å–º–µ—â–∞—è –æ—Ç—Ç–µ–Ω–æ–∫
  const accentHue = (hsl.h + 180) % 360; // –ö–æ–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π —Ü–≤–µ—Ç
  const accent = hslToString(accentHue, Math.min(70, hsl.s + 20), isDark ? 65 : 45);
  
  // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ —Ñ–æ–Ω—ã –¥–ª—è –ø–∞–Ω–µ–ª–µ–π —Å –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
  const panelBg = isDark 
    ? `rgba(${Math.floor(r/3)}, ${Math.floor(g/3)}, ${Math.floor(b/3)}, 0.75)` 
    : `rgba(${Math.min(r+20, 255)}, ${Math.min(g+20, 255)}, ${Math.min(b+20, 255)}, 0.75)`;
  
  const cardBg = isDark
    ? `rgba(${Math.floor(r/4)}, ${Math.floor(g/4)}, ${Math.floor(b/4)}, 0.8)`  
    : `rgba(${Math.min(r+30, 255)}, ${Math.min(g+30, 255)}, ${Math.min(b+30, 255)}, 0.75)`;
  
  return {
    primary,
    secondary,
    accent,
    text: textColor,
    textSecondary,
    panelBg,
    cardBg,
    borderRadius: 15,
    avatarSize: 160,
  };
}

/**
 * –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–æ–º–∏–Ω–∞–Ω—Ç–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤
 */
async function analyzeImageColors(image: any): Promise<RGB> {
  try {
    // –°–æ–∑–¥–∞–µ–º Canvas –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    const canvas = createCanvas(image.width, image.height);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0);
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å—Ä–µ–¥–Ω–µ–≥–æ —Ü–≤–µ—Ç–∞
    return computeAverageColor(image);
  } catch (error) {
    logger.error('Error analyzing image colors:', error);
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Å–µ—Ä—ã–π —Ü–≤–µ—Ç –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    return { r: 128, g: 128, b: 128 };
  }
}

/**
 * –í—ã—á–∏—Å–ª—è–µ—Ç —Å—Ä–µ–¥–Ω–∏–π —Ü–≤–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é —É–º–µ–Ω—å—à–µ–Ω–Ω–æ–≥–æ –æ–±—Ä–∞–∑—Ü–∞
 */
function computeAverageColor(image: any, sampleSize = 50): RGB {
  const offCanvas = createCanvas(sampleSize, sampleSize);
  const offCtx = offCanvas.getContext('2d');
  offCtx.drawImage(image, 0, 0, sampleSize, sampleSize);
  const data = offCtx.getImageData(0, 0, sampleSize, sampleSize).data;
  let r = 0, g = 0, b = 0;
  const count = data.length / 4;
  for (let i = 0; i < data.length; i += 4) {
    r += data[i];
    g += data[i + 1];
    b += data[i + 2];
  }
  return { r: Math.round(r / count), g: Math.round(g / count), b: Math.round(b / count) };
}

// -------------------- Polyfill for roundRect --------------------
const ctxPrototype = Object.getPrototypeOf(createCanvas(1,1).getContext('2d')) as any;
if (!ctxPrototype.roundRect) {
  ctxPrototype.roundRect = function(x: number, y: number, w: number, h: number, r: number) {
    if (r > w/2) r = w/2; if (r > h/2) r = h/2;
    this.beginPath(); this.moveTo(x+r,y);
    this.arcTo(x+w,y,x+w,y+h,r);
    this.arcTo(x+w,y+h,x,y+h,r);
    this.arcTo(x,y+h,x,y,r);
    this.arcTo(x,y,x+w,y,r);
    this.closePath(); return this;
  };
}

function createErrorCanvas(): Buffer {
  const canvas = createCanvas(800, 400);
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#1E1E1E';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.font = 'bold 32px Montserrat';
  ctx.fillStyle = '#FF6B00';
  ctx.textAlign = 'center';
  ctx.fillText('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤', canvas.width/2, canvas.height/2);
  return canvas.toBuffer();
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç —Ñ–æ–Ω —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–≤–µ—Ç–æ–≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
 */
async function drawBackground(
  ctx: CanvasRenderingContext2D,
  canvas: Canvas,
  bgImage: any,
  styles: Styles
): Promise<void> {
  // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ–≥–æ —Ö–æ–ª—Å—Ç–∞
  const scale = Math.max(canvas.width / bgImage.width, canvas.height / bgImage.height);
  const scaledWidth = bgImage.width * scale;
  const scaledHeight = bgImage.height * scale;
  const x = (canvas.width - scaledWidth) / 2;
  const y = (canvas.height - scaledHeight) / 2;
  
  // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
  ctx.drawImage(bgImage, x, y, scaledWidth, scaledHeight);
  
  // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –∑–∞—Ç–µ–º–Ω–µ–Ω–∏—è
  const overlayGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  overlayGradient.addColorStop(0, `rgba(0, 0, 0, 0.7)`);
  overlayGradient.addColorStop(0.4, `rgba(0, 0, 0, 0.6)`);
  overlayGradient.addColorStop(1, `rgba(0, 0, 0, 0.4)`);
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ
  ctx.fillStyle = overlayGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–Ω—å–µ—Ç–∫—É –ø–æ –∫—Ä–∞—è–º –¥–ª—è –ª—É—á—à–µ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
  const vignette = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
    canvas.width / 2, canvas.height / 2, canvas.width * 0.7
  );
  vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vignette.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
  
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

/**
 * –†–∏—Å—É–µ—Ç –ø–∞–Ω–µ–ª—å —Å –∑–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–º–∏ —É–≥–ª–∞–º–∏ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
 */
function drawPanel(
  ctx: CanvasRenderingContext2D, 
  x: number, 
  y: number, 
  width: number, 
  height: number, 
  radius: number, 
  styles: Styles
): void {
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≥–ª—É–±–∏–Ω—ã
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 3;
  
  // –§–æ–Ω –ø–∞–Ω–µ–ª–∏
  ctx.fillStyle = styles.panelBg;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.fill();
  ctx.restore();
  
  // –û–±–≤–æ–¥–∫–∞ –ø–∞–Ω–µ–ª–∏ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
  const strokeGradient = ctx.createLinearGradient(x, y, x + width, y + height);
  strokeGradient.addColorStop(0, styles.primary);
  strokeGradient.addColorStop(1, styles.secondary);
  
  ctx.strokeStyle = strokeGradient;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.stroke();
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—Ç–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ –≤–µ—Ä—Ö–Ω–µ–º—É –∫—Ä–∞—é –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
  const glowGradient = ctx.createLinearGradient(x, y, x, y + height * 0.1);
  glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
  glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  
  ctx.fillStyle = glowGradient;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height * 0.1, radius);
  ctx.fill();
}

/**
 * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –¥–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
function drawSkillTree(
    ctx: CanvasRenderingContext2D,
    skills: Skill[],
    styles: Styles,
    canvasWidth: number,
    canvasHeight: number
  ): void {
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–∞–Ω–µ–ª–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
    const treePanel = {
      x: 60,
      y: 90, // –£–≤–µ–ª–∏—á–µ–Ω –æ—Ç—Å—Ç—É–ø —Å–≤–µ—Ä—Ö—É –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞
      width: canvasWidth - 120,
      height: canvasHeight - 160,
      radius: styles.borderRadius
    };
    
    // –†–∏—Å—É–µ–º –ø–∞–Ω–µ–ª—å –¥–ª—è –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤
    drawPanel(ctx, treePanel.x, treePanel.y, treePanel.width, treePanel.height, treePanel.radius, styles);
    
    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±–ª–∞—Å—Ç–∏ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –≤–µ—Ç–æ–∫
    drawBranchAreas(ctx, treePanel, styles, skills);
    
    // –†–∏—Å—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–µ–ª–∏ —Å —Ç–µ–Ω—å—é –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    
    ctx.font = 'bold 32px Montserrat';
    ctx.fillStyle = styles.primary;
    ctx.textAlign = 'center';
    ctx.fillText('–î–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤', treePanel.x + treePanel.width / 2, treePanel.y + 40);
    ctx.restore();
    
    // –†–∏—Å—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –Ω–∞–≤—ã–∫–∞–º–∏ (–ª–∏–Ω–∏–∏)
    drawSkillConnections(ctx, skills, styles, treePanel);
    
    // –†–∏—Å—É–µ–º –∫–∞–∂–¥—ã–π –Ω–∞–≤—ã–∫
    skills.forEach(skill => {
      drawSkillNode(ctx, skill, styles, treePanel);
    });
  }
  
  /**
   * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –≤–µ—Ç–æ–∫ –Ω–∞–≤—ã–∫–æ–≤
   */
  function drawBranchAreas(
    ctx: CanvasRenderingContext2D,
    panel: { x: number; y: number; width: number; height: number },
    styles: Styles,
    skills: Skill[]
  ): void {
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞–≤—ã–∫–∏ —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã –∫–∞–∂–¥–æ–π –≤–µ—Ç–∫–∏
    const dailySkills = skills.filter(s => ['daily_rewards', 'daily_cooldown', 'cases_multi', 'cases_cooldown'].includes(s.id));
    const expAndTreasureSkills = skills.filter(s => ['exp_messages', 'exp_voice', 'treasure_hint', 'treasure_value', 'treasure_chance'].includes(s.id));
    const resetSkills = skills.filter(s => ['reset_level', 'reset_skills'].includes(s.id));
    
    // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã
    function getBranchBounds(skillGroup: Skill[]) {
      const positions = skillGroup.map(s => ({ x: panel.x + s.position.x, y: panel.y + s.position.y }));
      const minX = Math.min(...positions.map(p => p.x)) - 80;
      const minY = Math.min(...positions.map(p => p.y)) - 60;
      const maxX = Math.max(...positions.map(p => p.x)) + 80;
      const maxY = Math.max(...positions.map(p => p.y)) + 80;
      return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    
    const branches = [
      {
        name: '–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã –∏ –∫–µ–π—Å—ã',
        color: 'rgba(65, 105, 225, 0.1)', // –°–∏–Ω–∏–π
        ...getBranchBounds(dailySkills),
        radius: 15
      },
      {
        name: '–û–ø—ã—Ç –∏ –∫–ª–∞–¥–æ–∏—Å–∫–∞—Ç–µ–ª—å',
        color: 'rgba(60, 179, 113, 0.1)', // –ó–µ–ª–µ–Ω—ã–π
        ...getBranchBounds(expAndTreasureSkills),
        radius: 15
      },
      {
        name: '–°–±—Ä–æ—Å –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ',
        color: 'rgba(178, 34, 34, 0.1)', // –ö—Ä–∞—Å–Ω—ã–π
        ...getBranchBounds(resetSkills),
        radius: 15
      }
    ];
    
    ctx.save();
    
    // –†–∏—Å—É–µ–º –∫–∞–∂–¥—É—é –æ–±–ª–∞—Å—Ç—å
    branches.forEach(branch => {
      // –§–æ–Ω –¥–ª—è –æ–±–ª–∞—Å—Ç–∏
      ctx.fillStyle = branch.color;
      ctx.beginPath();
      ctx.roundRect(branch.x, branch.y, branch.width, branch.height, branch.radius);
      ctx.fill();
      
      // –¢–æ–Ω–∫–∞—è –æ–±–≤–æ–¥–∫–∞
      ctx.strokeStyle = branch.color.replace('0.1', '0.3');
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // –ù–∞–∑–≤–∞–Ω–∏–µ –≤–µ—Ç–∫–∏ (–º–∞–ª–µ–Ω—å–∫–∏–º —à—Ä–∏—Ñ—Ç–æ–º –≤ —É–≥–ª—É –∑–æ–Ω—ã)
      ctx.font = '14px Montserrat';
      ctx.fillStyle = branch.color.replace('0.1', '0.7');
      ctx.textAlign = 'left';
      ctx.fillText(branch.name, branch.x + 15, branch.y + 25);
    });
    
    ctx.restore();
  }
  
  /**
   * –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –º–µ—Ç–∫–∏ –≤–µ—Ç–æ–∫ –Ω–∞–≤—ã–∫–æ–≤
   */
  function drawBranchLabels(
    ctx: CanvasRenderingContext2D,
    panel: { x: number; y: number; width: number; height: number },
    styles: Styles
  ): void {
    const branchInfo = [
      {
        label: "–î–æ—Å—Ç—É–ø–Ω–æ —Å—Ä–∞–∑—É",
        x: panel.x + 120,
        y: panel.y + 85
      },
      {
        label: "–î–æ—Å—Ç—É–ø–Ω–æ —Å 7 —É—Ä–æ–≤–Ω—è",
        x: panel.x + 150,
        y: panel.y + 245
      },
      {
        label: "–î–æ—Å—Ç—É–ø–Ω–æ —Å 10 —É—Ä–æ–≤–Ω—è",
        x: panel.x + 750,
        y: panel.y + 245
      },
      {
        label: "–î–æ—Å—Ç—É–ø–Ω–æ —Å 20 —É—Ä–æ–≤–Ω—è",
        x: panel.x + 300,
        y: panel.y + 415
      }
    ];
    
    ctx.save();
    ctx.font = 'bold 14px Montserrat';
    ctx.textAlign = 'left';
    
    branchInfo.forEach(info => {
      // –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω –¥–ª—è —Ç–µ–∫—Å—Ç–∞
      const textWidth = ctx.measureText(info.label).width;
      const bgHeight = 20;
      const padding = 10;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.beginPath();
      ctx.roundRect(info.x - padding/2, info.y - 14, textWidth + padding, bgHeight, 5);
      ctx.fill();
      
      // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillText(info.label, info.x, info.y);
    });
    
    ctx.restore();
  }

/**
 * –†–∏—Å—É–µ—Ç —Å–æ–µ–¥–∏–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –º–µ–∂–¥—É –Ω–∞–≤—ã–∫–∞–º–∏
 */
function drawSkillConnections(
  ctx: CanvasRenderingContext2D,
  skills: Skill[],
  styles: Styles,
  panel: { x: number; y: number; width: number; height: number }
): void {
  ctx.save();
  
  // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–∞–≤—ã–∫–∞ —Ä–∏—Å—É–µ–º –µ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
  skills.forEach(skill => {
    const startX = panel.x + skill.position.x;
    const startY = panel.y + skill.position.y;
    
    // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–∞–≤—ã–∫–∞
    skill.connections.forEach(connectionId => {
      const connectedSkill = skills.find(s => s.id === connectionId);
      if (connectedSkill) {
        const endX = panel.x + connectedSkill.position.x;
        const endY = panel.y + connectedSkill.position.y;
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∏–ª—å –ª–∏–Ω–∏–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –Ω–∞–≤—ã–∫–æ–≤
        if (skill.unlocked) {
          if (connectedSkill.unlocked) {
            // –û–±–∞ –Ω–∞–≤—ã–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã - —Ä–∏—Å—É–µ–º –∫—Ä–∞—Å–∏–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            gradient.addColorStop(0, styles.primary);
            gradient.addColorStop(1, styles.secondary);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
          } else {
            // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º –Ω–∞–≤—ã–∫–æ–º - –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –ª–∏–Ω–∏—è
            ctx.strokeStyle = 'rgba(180, 180, 180, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]); // –ü—É–Ω–∫—Ç–∏—Ä–Ω–∞—è –ª–∏–Ω–∏—è
          }
        } else {
          // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ - —Å–µ—Ä–∞—è –ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è –ª–∏–Ω–∏—è
          ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 4]);
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–∏–≤–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
        if (skill.unlocked && connectedSkill.unlocked) {
          ctx.shadowColor = styles.primary;
          ctx.shadowBlur = 5;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        } else {
          ctx.shadowBlur = 0;
        }
        
        // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]); // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—É–Ω–∫—Ç–∏—Ä–Ω—É—é –ª–∏–Ω–∏—é
      }
    });
  });
  
  ctx.restore();
}

/**
 * –†–∏—Å—É–µ—Ç —É–∑–µ–ª –Ω–∞–≤—ã–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ–º —Ç–µ–∫—Å—Ç–∞
 */
function drawSkillNode(
    ctx: CanvasRenderingContext2D,
    skill: Skill,
    styles: Styles,
    panel: { x: number; y: number; width: number; height: number }
  ): void {
    const nodeRadius = 30;
    const x = panel.x + skill.position.x;
    const y = panel.y + skill.position.y;
    
    ctx.save();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –Ω–∞–≤—ã–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ –ø–æ —É—Ä–æ–≤–Ω—é
    const hasLevelRequirement = 'requiredLevel' in skill && skill.requiredLevel! > 0;
    
    // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–≤—ã–∫–æ–≤
    if (skill.unlocked) {
      // –ö—Ä–∞—Å–∏–≤—ã–π —ç—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–≤—ã–∫–æ–≤
      const glowRadius = nodeRadius + 8;
      const glowGradient = ctx.createRadialGradient(
        x, y, nodeRadius - 5,
        x, y, glowRadius
      );
      glowGradient.addColorStop(0, `${styles.primary}60`); // 40% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
      glowGradient.addColorStop(1, `${styles.primary}00`); // 0% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
      
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∏–ª—å —Ñ–æ–Ω–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞ –Ω–∞–≤—ã–∫–∞
    let bgGradient;
    if (skill.unlocked) {
      // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –Ω–∞–≤—ã–∫–∞
      bgGradient = ctx.createRadialGradient(
        x - nodeRadius/3, y - nodeRadius/3, 0,
        x, y, nodeRadius
      );
      bgGradient.addColorStop(0, styles.cardBg);
      bgGradient.addColorStop(1, styles.panelBg);
    } else {
      // –ë–æ–ª–µ–µ —Ç—É—Å–∫–ª—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –Ω–∞–≤—ã–∫–∞
      bgGradient = ctx.createRadialGradient(
        x, y, 0,
        x, y, nodeRadius
      );
      bgGradient.addColorStop(0, 'rgba(80, 80, 80, 0.5)');
      bgGradient.addColorStop(1, 'rgba(50, 50, 50, 0.5)');
    }
    
    // –†–∏—Å—É–µ–º —Ñ–æ–Ω —É–∑–ª–∞
    ctx.fillStyle = bgGradient;
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // –†–∏—Å—É–µ–º –æ–±–≤–æ–¥–∫—É
    ctx.strokeStyle = skill.unlocked ? styles.primary : 'rgba(100, 100, 100, 0.6)';
    ctx.lineWidth = skill.unlocked ? 3 : 1;
    ctx.beginPath();
    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // –†–∏—Å—É–µ–º –ø–µ—Ä–≤—ã–µ 2 –±—É–∫–≤—ã –Ω–∞–∑–≤–∞–Ω–∏—è –Ω–∞–≤—ã–∫–∞
    ctx.font = 'bold 18px Montserrat';
    ctx.fillStyle = skill.unlocked ? styles.accent : 'rgba(150, 150, 150, 0.7)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(skill.name.substring(0, 2), x, y - 8);
    
    // –†–∏—Å—É–µ–º —É—Ä–æ–≤–µ–Ω—å –Ω–∞–≤—ã–∫–∞
    ctx.fillStyle = skill.unlocked ? styles.text : 'rgba(150, 150, 150, 0.7)';
    ctx.font = `bold ${skill.unlocked ? 16 : 14}px Montserrat`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${skill.level}/${skill.maxLevel}`, x, y + 10);
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ–Ω—å—à–∏–π —à—Ä–∏—Ñ—Ç –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –Ω–∞–ª–æ–∂–µ–Ω–∏—è
    const nameLines = getTextLines(skill.name, 120); // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –Ω–∞–∑–≤–∞–Ω–∏—è –≤ –ø–∏–∫—Å–µ–ª—è—Ö
    
    // –†–∏—Å—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–∞–≤—ã–∫–∞ —Å–Ω–∏–∑—É —É–∑–ª–∞ (–≤–æ–∑–º–æ–∂–Ω–æ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫)
    ctx.font = skill.unlocked ? 'bold 14px Montserrat' : '12px Montserrat'; // –£–º–µ–Ω—å—à–µ–Ω —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
    ctx.fillStyle = skill.unlocked ? styles.text : 'rgba(150, 150, 150, 0.7)';
    ctx.textAlign = 'center';
    
    // –ï—Å–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ—Ä–æ—Ç–∫–æ–µ - –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
    if (nameLines.length === 1) {
      ctx.fillText(skill.name, x, y + nodeRadius + 18);
    } else {
      // –ï—Å–ª–∏ –¥–ª–∏–Ω–Ω–æ–µ - —Ä–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –¥–≤–µ —Å—Ç—Ä–æ–∫–∏
      nameLines.forEach((line, index) => {
        ctx.fillText(line, x, y + nodeRadius + 12 + (index * 16));
      });
    }
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ –ø–æ —É—Ä–æ–≤–Ω—é, –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –µ–≥–æ –Ω–∏–∂–µ –Ω–∞–∑–≤–∞–Ω–∏—è
    if (hasLevelRequirement) {
      const yOffset = nameLines.length > 1 ? 34 + ((nameLines.length - 1) * 16) : 34;
      ctx.font = '12px Montserrat';
      ctx.fillStyle = 'rgba(255, 200, 50, 0.9)';
      ctx.textAlign = 'center';
      ctx.fillText(`–î–æ—Å—Ç—É–ø–µ–Ω —Å ${skill.requiredLevel} —É—Ä.`, x, y + nodeRadius + yOffset);
      
      // –î–æ–±–∞–≤–ª—è–µ–º –∑–Ω–∞—á–æ–∫ –∑–∞–º–∫–∞ –¥–ª—è –Ω–∞–≤—ã–∫–æ–≤ —Å —É—Ä–æ–≤–Ω–µ–≤—ã–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ–º
      if (!skill.unlocked) {
        ctx.fillStyle = 'rgba(255, 200, 50, 0.7)';
        ctx.beginPath();
        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—Ä–æ—Å—Ç–æ–≥–æ –∑–Ω–∞—á–∫–∞ –∑–∞–º–∫–∞
        const lockSize = 10;
        const lockX = x + nodeRadius - lockSize;
        const lockY = y - nodeRadius + lockSize;
        
        // –¢–µ–ª–æ –∑–∞–º–∫–∞
        ctx.fillRect(lockX - lockSize/2, lockY, lockSize, lockSize);
        
        // –î—É–∂–∫–∞ –∑–∞–º–∫–∞
        ctx.beginPath();
        ctx.arc(lockX, lockY - lockSize/4, lockSize/2, Math.PI, 2 * Math.PI);
        ctx.fill();
      }
    }
    
    // –ï—Å–ª–∏ –Ω–∞–≤—ã–∫ –∏–º–µ–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å, –¥–æ–±–∞–≤–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç –∑–≤–µ–∑–¥—ã
    if (skill.level === skill.maxLevel && skill.unlocked) {
      drawMaxLevelEffect(ctx, x, y - nodeRadius - 5, styles);
    }
    
    ctx.restore();
  }

/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫, –µ—Å–ª–∏ –æ–Ω —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π
 */
function getTextLines(text: string, maxWidth: number): string[] {
    // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –∫–æ—Ä–æ—Ç–∫–∏–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –∫–∞–∫ –µ—Å—Ç—å
    if (text.length <= 12) {
      return [text];
    }
    
    // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —É–¥–æ–±–Ω–æ–µ –º–µ—Å—Ç–æ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è (–ø—Ä–æ–±–µ–ª)
    const middleIndex = Math.floor(text.length / 2);
    let splitIndex = text.lastIndexOf(' ', middleIndex);
    
    // –ï—Å–ª–∏ –ø—Ä–æ–±–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ, –∏—â–µ–º –ø–æ—Å–ª–µ —Å–µ—Ä–µ–¥–∏–Ω—ã
    if (splitIndex === -1 || splitIndex < 4) {
      splitIndex = text.indexOf(' ', middleIndex);
    }
    
    // –ï—Å–ª–∏ –ø—Ä–æ–±–µ–ª –≤–æ–æ–±—â–µ –Ω–µ –Ω–∞–π–¥–µ–Ω, –¥–µ–ª–∏–º –º–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∏
    if (splitIndex === -1) {
      splitIndex = middleIndex;
    }
    
    return [
      text.substring(0, splitIndex),
      text.substring(splitIndex + 1)
    ];
  }

/**
 * –†–∏—Å—É–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç "–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è" –Ω–∞–¥ –Ω–∞–≤—ã–∫–æ–º (–∫–æ—Ä–æ–Ω–∞ –∏–ª–∏ –∑–≤–µ–∑–¥–∞)
 */
function drawMaxLevelEffect(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  styles: Styles
): void {
  const size = 12; // –†–∞–∑–º–µ—Ä —ç—Ñ—Ñ–µ–∫—Ç–∞
  
  ctx.save();
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ
  ctx.shadowColor = styles.accent;
  ctx.shadowBlur = 5;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  
  // –†–∏—Å—É–µ–º –∑–≤–µ–∑–¥—É
  ctx.fillStyle = styles.accent;
  ctx.beginPath();
  
  // –†–∏—Å—É–µ–º 5-–∫–æ–Ω–µ—á–Ω—É—é –∑–≤–µ–∑–¥—É
  for(let i = 0; i < 5; i++) {
    const angle = (Math.PI * 2 * i / 5) - Math.PI / 2;
    const outerX = x + Math.cos(angle) * size;
    const outerY = y + Math.sin(angle) * size;
    
    if(i === 0) {
      ctx.moveTo(outerX, outerY);
    } else {
      ctx.lineTo(outerX, outerY);
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ç–æ—á–∫–∏ –∑–≤–µ–∑–¥—ã
    const innerAngle = angle + Math.PI / 5;
    const innerX = x + Math.cos(innerAngle) * (size / 2.5);
    const innerY = y + Math.sin(innerAngle) * (size / 2.5);
    ctx.lineTo(innerX, innerY);
  }
  
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –Ω–∞–≤—ã–∫–æ–≤
 * –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –Ω–∞–≤—ã–∫–∏ –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –¥—Ä—É–≥–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
 */
/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∞–±–æ—Ä–∞ –Ω–∞–≤—ã–∫–æ–≤ —Å–æ–≥–ª–∞—Å–Ω–æ –æ–ø–∏—Å–∞–Ω–∏—é
 */
/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∞–±–æ—Ä–∞ –Ω–∞–≤—ã–∫–æ–≤ —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏
 */
export function generateDemoSkills(): Skill[] {
    return [
      // –í–µ—Ç–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥
      {
        id: 'daily_rewards',
        name: '–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã',
        level: 0,
        maxLevel: 4,
        description: '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥ –Ω–∞ 50$ –∑–∞ —É—Ä–æ–≤–µ–Ω—å',
        unlocked: true,
        position: { x: 200, y: 150 }, // –°–¥–≤–∏–Ω—É—Ç–æ –ª–µ–≤–µ–µ
        connections: ['daily_cooldown']
      },
      {
        id: 'daily_cooldown',
        name: '–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞',
        level: 0,
        maxLevel: 4,
        description: '–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–æ–∫ –Ω–∞ 40 –º–∏–Ω –∑–∞ —É—Ä–æ–≤–µ–Ω—å',
        unlocked: true,
        position: { x: 400, y: 150 }, // –£–≤–µ–ª–∏—á–µ–Ω –æ—Ç—Å—Ç—É–ø
        connections: ['daily_rewards', 'cases_multi']
      },
      
      // –í–µ—Ç–∫–∞ –∫–µ–π—Å–æ–≤
      {
        id: 'cases_multi',
        name: '–ú—É–ª—å—Ç–∏-–ø–æ–¥–∞—Ä–æ–∫',
        level: 0,
        maxLevel: 4,
        description: '–®–∞–Ω—Å –Ω–∞ –º—É–ª—å—Ç–∏-–ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–∞—Ä–∫–∞ (25% –∑–∞ —É—Ä–æ–≤–µ–Ω—å)',
        unlocked: true,
        position: { x: 600, y: 150 }, // –£–≤–µ–ª–∏—á–µ–Ω –æ—Ç—Å—Ç—É–ø
        connections: ['daily_cooldown', 'cases_cooldown']
      },
      {
        id: 'cases_cooldown',
        name: '–ë—ã—Å—Ç—Ä—ã–µ –ø–æ–¥–∞—Ä–∫–∏',
        level: 0,
        maxLevel: 4,
        description: '–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥–∞—Ä–∫–∞ –Ω–∞ 30 –º–∏–Ω –∑–∞ —É—Ä–æ–≤–µ–Ω—å',
        unlocked: true,
        position: { x: 800, y: 150 }, // –£–≤–µ–ª–∏—á–µ–Ω –æ—Ç—Å—Ç—É–ø
        connections: ['cases_multi', 'exp_messages']
      },
      
      // –í–µ—Ç–∫–∞ —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–ø—ã—Ç–∞
      {
        id: 'exp_messages',
        name: 'XP –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏—è',
        level: 0,
        maxLevel: 1,
        description: '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ–ø—ã—Ç–∞ –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏—è (1—Ö–ø ‚Üí 2—Ö–ø)',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 10 —É—Ä–æ–≤–Ω—è
        requiredLevel: 10,
        position: { x: 800, y: 300 }, // –°–¥–≤–∏–Ω—É—Ç–æ –≤–Ω–∏–∑
        connections: ['cases_cooldown', 'exp_voice']
      },
      {
        id: 'exp_voice',
        name: 'XP –∑–∞ –≥–æ–ª–æ—Å',
        level: 0,
        maxLevel: 1,
        description: '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ–ø—ã—Ç–∞ –∑–∞ –≤–æ–π—Å (5—Ö–ø ‚Üí 6—Ö–ø)',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 10 —É—Ä–æ–≤–Ω—è
        requiredLevel: 10,
        position: { x: 600, y: 300 }, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é
        connections: ['exp_messages', 'treasure_hint']
      },
      
      // –í–µ—Ç–∫–∞ –∫–ª–∞–¥–æ–∏—Å–∫–∞—Ç–µ–ª—è
      {
        id: 'treasure_hint',
        name: '–î–æ–ø. –ø–æ–¥—Å–∫–∞–∑–∫–∞',
        level: 0,
        maxLevel: 1,
        description: '–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–æ–∫—Ä–æ–≤–∏—â',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 7 —É—Ä–æ–≤–Ω—è
        requiredLevel: 7,
        position: { x: 400, y: 300 }, // –£–≤–µ–ª–∏—á–µ–Ω –æ—Ç—Å—Ç—É–ø
        connections: ['exp_voice', 'treasure_value']
      },
      {
        id: 'treasure_value',
        name: '–ë–æ–≥–∞—Ç—ã–µ —Å–æ–∫—Ä–æ–≤–∏—â–∞',
        level: 0,
        maxLevel: 1,
        description: '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤—Å–µ—Ö –Ω–∞–≥—Ä–∞–¥ –æ—Ç —Å–æ–∫—Ä–æ–≤–∏—â –Ω–∞ 500$',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 7 —É—Ä–æ–≤–Ω—è
        requiredLevel: 7,
        position: { x: 200, y: 300 }, // –£–≤–µ–ª–∏—á–µ–Ω –æ—Ç—Å—Ç—É–ø
        connections: ['treasure_hint', 'treasure_chance']
      },
      {
        id: 'treasure_chance',
        name: '–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞',
        level: 0,
        maxLevel: 4,
        description: '–®–∞–Ω—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–æ–ø. –∫–∞—Ä—Ç—ã —Å–æ–∫—Ä–æ–≤–∏—â (2.5% –∑–∞ —É—Ä–æ–≤–µ–Ω—å)',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 7 —É—Ä–æ–≤–Ω—è
        requiredLevel: 7,
        position: { x: 100, y: 220 }, // –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∑–∏—Ü–∏—è
        connections: ['treasure_value', 'reset_level']
      },
      
      // –í–µ—Ç–∫–∞ —Å–±—Ä–æ—Å–∞
      {
        id: 'reset_level',
        name: '–°–±—Ä–æ—Å —É—Ä–æ–≤–Ω—è',
        level: 0,
        maxLevel: 1,
        description: '–°–±—Ä–æ—Å —É—Ä–æ–≤–Ω—è –∏ –≤—Å–µ—Ö –æ—á–∫–æ–≤ –Ω–∞–≤—ã–∫–æ–≤',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 20 —É—Ä–æ–≤–Ω—è
        requiredLevel: 20,
        position: { x: 200, y: 450 }, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é
        connections: ['treasure_chance', 'reset_skills']
      },
      {
        id: 'reset_skills',
        name: '–°–±—Ä–æ—Å –Ω–∞–≤—ã–∫–æ–≤',
        level: 0,
        maxLevel: 1,
        description: '–°–±—Ä–æ—Å –æ—á–∫–æ–≤ –Ω–∞–≤—ã–∫–æ–≤ (—Ä–∞–∑ –≤ –Ω–µ–¥–µ–ª—é, —Å—Ç–æ–∏–º–æ—Å—Ç—å 15000$)',
        unlocked: false, // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ 20 —É—Ä–æ–≤–Ω—è
        requiredLevel: 20,
        position: { x: 400, y: 450 }, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é
        connections: ['reset_level']
      }
    ];
  }
  
  /**
   * –ë–∞–∑–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤
   * –±–µ–∑ –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
   */
  export async function generateBasicSkillTreeImage(
    skills: Skill[] = generateDemoSkills(),
    backgroundImagePath?: string
  ): Promise<Buffer> {
    try {
      // –î–ª—è –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤ –Ω—É–∂–µ–Ω –±–æ–ª–µ–µ —à–∏—Ä–æ–∫–∏–π —Ö–æ–ª—Å—Ç
      const canvas = createCanvas(1200, 800);
      const ctx = canvas.getContext('2d');
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ
      const bgPath = backgroundImagePath || path.join(__dirname, '../../assets/images/background.png');
      const bgImage = await loadImage(bgPath);
      
      // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ü–≤–µ—Ç–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      const avgColor = await analyzeImageColors(bgImage);
      const styles = generateStylesFromColor(avgColor);
      
      // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ñ–æ–Ω —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ–º
      await drawBackground(ctx, canvas, bgImage, styles);
      
      // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–ª—è –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤ –≤ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      ctx.save();
      ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
      ctx.shadowBlur = 5;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      
      ctx.font = 'bold 48px Montserrat';
      ctx.fillStyle = styles.text;
      ctx.textAlign = 'center';
      ctx.fillText('–î–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤', canvas.width / 2, 60);
      ctx.restore();
      
      // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –¥–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤
      drawSkillTree(ctx, skills, styles, canvas.width, canvas.height);
      
      return canvas.toBuffer();
    } catch (error: unknown) {
      logger.error('Error generating skill tree image:', error);
      return createErrorCanvas();
    }
  }

# ./src/commands/rolesCommands.ts
import { Discord, Slash, SlashOption, SlashChoice, Guard, SlashGroup } from "discordx";
import { CommandInteraction, ApplicationCommandOptionType, TextChannel } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { Config } from "../entities/Config.js";
import { RequireRoles } from "../utils/decorators/RequireRoles.js";
import { createSuccessEmbed, createErrorEmbed } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { RoleSelector } from "../events/RoleSelectorListener.js";

@Discord()
@SlashGroup({
    description: "–ö–æ–º–∞–Ω–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–æ–ª—è–º–∏",
    name: "roles",
    dmPermission: false,
})
@SlashGroup("roles")
export class RoleCommands {    
    @Slash({ description: "–°–æ–∑–¥–∞—Ç—å –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–µ–π –≤ —Ç–µ–∫—É—â–µ–º –∫–∞–Ω–∞–ª–µ" })
    @Guard(RequireRoles(["high_mod_level"]))
    async chat(interaction: CommandInteraction): Promise<void> {
        await interaction.deferReply({ ephemeral: true });
        
        try {
            const configRepository = AppDataSource.getRepository(Config);
            
            const isRoleChannel = await configRepository.findOne({
                where: { key: "give_role_chat", value: interaction.channelId }
            });
            
            if (!isRoleChannel) {
                const embed = createErrorEmbed("–≠—Ç–æ—Ç –∫–∞–Ω–∞–ª –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∫–∞–∫ –∫–∞–Ω–∞–ª –¥–ª—è –≤—ã–¥–∞—á–∏ —Ä–æ–ª–µ–π. –°–Ω–∞—á–∞–ª–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /config add —Å –∫–ª—é—á–æ–º give_role_chat", interaction.user);
                await interaction.editReply({ embeds: [embed] });
                return;
            }
            
            await RoleSelector.createRoleMenu(interaction.channelId, interaction.client);
            
            const embed = createSuccessEmbed("–ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–µ–π —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–æ –≤ —ç—Ç–æ–º –∫–∞–Ω–∞–ª–µ.", interaction.user);
            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ–Ω—é —Ä–æ–ª–µ–π: ${error}`);
            
            const embed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ–Ω—é —Ä–æ–ª–µ–π.", interaction.user);
            await interaction.editReply({ embeds: [embed] });
        }
    }
}

# ./src/commands/expCommands.ts
import {
  Discord,
  SlashGroup,
  Slash,
  SlashOption,
  Guard
} from "discordx";
import {
  CommandInteraction,
  User as DiscordUser,
  ApplicationCommandOptionType
} from "discord.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { AppDataSource } from "../services/database.js";
import { User } from "../entities/User.js";
import { Exp } from "../entities/Exp.js";
import { RequireRoles } from "../utils/decorators/RequireRoles.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { getMaxLevelForExp } from "../utils/levelUpUtils.js";
import {
  createErrorEmbed,
  createSuccessEmbed,
  createExpTopEmbed,
  createExpEmbed
} from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";

@Discord()
@SlashGroup({ 
  description: "–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è EXP", 
  name: "exp",
  defaultMemberPermissions: "0", 
  dmPermission: false, 
})
@SlashGroup("exp")
class ExpCommands {
  @Slash({ description: "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–ª-–≤–æ EXP –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é" })
  @EnsureUser()
  @Guard(
      EnsureUserGuard(),
      RequireRoles(["high_mod_level", "medium_mod_level"])
  )
  async set(
    @SlashOption({
      description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
      name: "user",
      required: true,
      type: ApplicationCommandOptionType.User
    })
    discordUser: DiscordUser,
    @SlashOption({
      description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ EXP –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é",
      name: "exp",
      required: true,
      type: ApplicationCommandOptionType.Number
    })
    expCount: number,
    interaction: CommandInteraction,
  ) {
    try {
      const expRepository = AppDataSource.getRepository(Exp);

      const user = await AppDataSource.getRepository(User).findOneOrFail({
        where: { discordId: discordUser.id },
        relations: ["exp"]
      });

      user.exp.exp = BigInt(expCount);
      user.exp.level = getMaxLevelForExp(user.exp.exp);

      await expRepository.save(user.exp);
      logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${discordUser.id} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ ${expCount} EXP –∏ —É—Ä–æ–≤–µ–Ω—å ${user.exp.level}`);

      const embed = createSuccessEmbed(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${discordUser.id}> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ ${expCount} EXP (—É—Ä–æ–≤–µ–Ω—å ${user.exp.level})`, interaction.user);
      await interaction.reply({ embeds: [embed] });

    } catch (error) {
      const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
      await interaction.reply({ embeds: [embed] });
      logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ EXP: %O", error);
    }
  }

  @Slash({ description: "–î–æ–±–∞–≤–∏—Ç—å –∫–æ–ª-–≤–æ EXP –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é" })
  @EnsureUser()
  @Guard(
    EnsureUserGuard(),
    RequireRoles(["high_mod_level", "medium_mod_level"])
  )
  async add(
    @SlashOption({
      description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
      name: "user",
      required: true,
      type: ApplicationCommandOptionType.User
    })
    discordUser: DiscordUser,
    @SlashOption({
      description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ EXP –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è",
      name: "exp",
      required: true,
      type: ApplicationCommandOptionType.Number
    })
    expCount: number,
    interaction: CommandInteraction,
  ) {
    try {
      const expRepository = AppDataSource.getRepository(Exp);

      const user = await AppDataSource.getRepository(User).findOneOrFail({
        where: { discordId: discordUser.id },
        relations: ["exp"]
      });

      const oldLevel = user.exp.level;
      await expRepository.increment({ id: user.exp.id }, "exp", expCount);

      const newExp = await expRepository.findOneOrFail({ where: { id: user.exp.id } });
      const newLevel = getMaxLevelForExp(newExp.exp);

      if (newLevel !== oldLevel) {
        user.exp.level = newLevel;
        const levelUpMsg = `\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–≤—ã—Å–∏–ª —É—Ä–æ–≤–µ–Ω—å –¥–æ ${newLevel}! üéâ`;
        const embed = createSuccessEmbed(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${discordUser.id}> –¥–æ–±–∞–≤–ª–µ–Ω–æ EXP: +${expCount}${levelUpMsg}`, interaction.user);
        await interaction.reply({ embeds: [embed] });
      } else {
        const embed = createSuccessEmbed(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${discordUser.id}> –¥–æ–±–∞–≤–ª–µ–Ω–æ EXP: +${expCount}`, interaction.user);
        await interaction.reply({ embeds: [embed] });
      }
      await expRepository.save(user.exp);

      logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${discordUser.id} –¥–æ–±–∞–≤–ª–µ–Ω–æ ${expCount} EXP, —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å: ${newLevel}`);

    } catch (error) {
      const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
      await interaction.reply({ embeds: [embed] });
      logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ EXP: %O", error);
    }
  }

  @Slash({ description: "–°–Ω—è—Ç—å EXP —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è" })
  @EnsureUser()
  @Guard(
    EnsureUserGuard(),
    RequireRoles(["high_mod_level", "medium_mod_level"])
  )
  async remove(
    @SlashOption({
      description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
      name: "user",
      required: true,
      type: ApplicationCommandOptionType.User
    })
    discordUser: DiscordUser,
    @SlashOption({
      description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ EXP –¥–ª—è –≤—ã—á–∏—Ç–∞–Ω–∏—è",
      name: "exp",
      required: true,
      type: ApplicationCommandOptionType.Number
    })
    expCount: number,
    interaction: CommandInteraction,
  ) {
    try {
      const expRepository = AppDataSource.getRepository(Exp);

      const user = await AppDataSource.getRepository(User).findOneOrFail({
        where: { discordId: discordUser.id },
        relations: ["exp"]
      });

      const oldLevel = user.exp.level;
      const currentExp = Number(user.exp.exp);
      const finalExp = Math.max(0, currentExp - expCount);
      const actualDecrease = currentExp - finalExp;

      user.exp.exp = BigInt(finalExp);
      const newLevel = getMaxLevelForExp(user.exp.exp);

      if (newLevel !== oldLevel) {
        user.exp.level = newLevel;
        await expRepository.save(user.exp);

        const levelDownMsg = `\n–£—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ–Ω–∏–∑–∏–ª—Å—è –¥–æ ${newLevel}.`;
        const embed = createSuccessEmbed(`–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <@${discordUser.id}> –≤—ã—á—Ç–µ–Ω–æ EXP: -${actualDecrease}${levelDownMsg}`, interaction.user);
        await interaction.reply({ embeds: [embed] });
      } else {
        await expRepository.save(user.exp);
        const embed = createSuccessEmbed(`–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <@${discordUser.id}> –≤—ã—á—Ç–µ–Ω–æ EXP: -${actualDecrease}`, interaction.user);
        await interaction.reply({ embeds: [embed] });
      }

      logger.info(`–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordUser.id} –≤—ã—á—Ç–µ–Ω–æ ${actualDecrease} EXP, —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å: ${newLevel}`);

    } catch (error) {
      const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
      await interaction.reply({ embeds: [embed] });
      logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ EXP: %O", error);
    }
  }
}

export default ExpCommands;

# ./src/commands/coinFlipCommand.ts
import { Discord, Slash, SlashOption, Guard, SlashChoice } from "discordx";
import { CommandInteraction, ApplicationCommandOptionType } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User } from "../entities/User.js";
import { Currency } from "../entities/Currency.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { createErrorEmbed, createCoinflipEmbed } from "../utils/embedBuilder.js";
import { CheckMoney } from "../utils/decorators/CheckMoney.js";
import { Cooldown } from "../utils/decorators/CoommandCooldown.js";
import logger from "../services/logger.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";

@Discord()
class CoinflipCommand {
    @Slash({ description: "–ü–æ–¥–∫–∏–Ω—É—Ç—å –º–æ–Ω–µ—Ç–∫—É" })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        CheckMoney(),
        EnsureUserGuard(),
        Cooldown({ minutes: 1 })
    )
    async coin(
        @SlashChoice({ name: "–û—Ä–µ–ª", value: "eagle" })
        @SlashChoice({ name: "–†–µ—à–∫–∞", value: "reshka" })
        @SlashOption({
            name: "side",
            description: "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–æ—Ä–æ–Ω—É",
            type: ApplicationCommandOptionType.String,
            required: true
        })
        side: string,
        @SlashOption({
            name: "bet",
            description: "–°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏",
            minValue: 50,
            maxValue: 250,
            type: ApplicationCommandOptionType.Number,
            required: true
        })
        bet: number,
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();

            const userRepository = AppDataSource.getRepository(User);
            const currencyRepository = AppDataSource.getRepository(Currency);

            const user = await userRepository.findOne({
                where: { discordId: interaction.user.id },
                relations: ["currency"]
            });

            if (!user || !user.currency) {
                throw new Error("User not found");
            }

            const sides = ["eagle", "reshka"];
            const botSide = sides[Math.floor(Math.random() * sides.length)];
            const isWin = botSide === side;
            const winValue = 2 * bet
            const embed = createCoinflipEmbed(
                bet,
                interaction.user,
                side,
                isWin ? Math.floor(winValue - winValue * 0.07) : 0,
                isWin ? 1 : 0,
                botSide
            );

            if (isWin) {
                user.currency.currencyCount += BigInt(Math.floor(winValue - winValue * 0.07));
            } else {
                user.currency.currencyCount -= BigInt(bet);
            }

            await currencyRepository.save(user.currency);
            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ coinflip:", error);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞", interaction.user);
            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
        }
    }
}

export default CoinflipCommand;

# ./src/commands/topCommand.ts
import { Discord, Guard, Slash, SlashChoice, SlashOption } from "discordx";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";
import { ApplicationCommandOptionType, CommandInteraction, Embed } from "discord.js";
import { createTopEmbed, createErrorEmbed, EmbedColors } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { AppDataSource } from "../services/database.js";
import { Currency } from "../entities/Currency.js";
import { User } from "../entities/User.js";
import { getHoursString } from "../utils/hoursUtils.js";

@Discord()
class TopCommand {
    @Slash({ description: "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π" })
    @Guard(
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async top(
        @SlashChoice({ name: "–í–∞–ª—é—Ç–∞", value: "currency"})
        @SlashChoice({ name: "–ì–æ–ª–æ—Å–æ–≤–æ–π", value: "voice"})
        @SlashOption({
            description: "–¢–∏–ø —Ç–æ–ø–∞",
            name: "type",
            required: true,
            type: ApplicationCommandOptionType.String
        })
        topType: string,
        @SlashOption({
            description: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è",
            name: "limit",
            required: false,
            type: ApplicationCommandOptionType.Number
        })
        limit: number = 10,
        interaction: CommandInteraction,
    ) {
        try {
            if (limit <= 0 || limit > 25) limit = 10;
    
            if (topType === "voice") {
                const userRepository = AppDataSource.getRepository(User);
                const topUsers = await userRepository
                    .createQueryBuilder("user")
                    .orderBy("user.voiceMinutes", "DESC")
                    .take(limit)
                    .getMany();
    
                if (topUsers.length === 0) {
                    const embed = createErrorEmbed("–ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –≥–æ–ª–æ—Å–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏!", interaction.user);
                    return interaction.reply({ embeds: [embed] });
                }
    
                const embed = createTopEmbed(
                    topUsers.map((u) => ({ 
                        user: u, 
                        value: Math.round(Number(u.voiceMinutes) / 60), 
                        displayValue: `${Math.round(Number(u.voiceMinutes) / 60)} ${getHoursString(Math.round(Number(u.voiceMinutes) / 60))}` 
                    })),
                    limit,
                    interaction.user,
                    interaction.guild,
                    {
                        title: `üéôÔ∏è –¢–æ–ø ${limit} –ø–æ –≥–æ–ª–æ—Å–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏`,
                        description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ –±–æ–ª—å—à–µ –≤—Å–µ—Ö —Å–∏–¥–µ–ª–∏ –≤ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —á–∞—Ç–∞—Ö",
                        icon: "", 
                        color: EmbedColors.INFO
                    }
                );
    
                return interaction.reply({ embeds: [embed] });
            }
    
            const currencyRepository = AppDataSource.getRepository(Currency);
            const topUsers = await currencyRepository
                .createQueryBuilder("currency")
                .leftJoinAndSelect("currency.user", "user")
                .orderBy("currency.currencyCount", "DESC")
                .take(limit)
                .getMany();
    
            if (topUsers.length === 0) {
                const embed = createErrorEmbed("–ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø–æ–∫–∞ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –≤–∞–ª—é—Ç–æ–π!", interaction.user);
                return interaction.reply({ embeds: [embed] });
            }
    
            const embed = createTopEmbed(
                topUsers.map((c) => ({ 
                    user: c.user, 
                    value: c.currencyCount,
                    displayValue: c.currencyCount.toString() 
                })),
                limit,
                interaction.user,
                interaction.guild,
                {
                    title: `üí∞ –¢–æ–ø ${limit} –ø–æ –≤–∞–ª—é—Ç–µ`,
                    description: "–°–∞–º—ã–µ –±–æ–≥–∞—Ç—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–µ—Ä–≤–µ—Ä–∞",
                    icon: "üí∞",
                    color: EmbedColors.CURRENCY
                }
            );
    
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
            await interaction.reply({ embeds: [embed] });
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–æ–ø–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: %O", error);
        }
    }
}

export default TopCommand;

# ./src/commands/modProfile.ts
import { Discord, Slash, SlashOption, Guard } from "discordx";
import { CommandInteraction, User, ApplicationCommandOptionType } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User as DBUser } from "../entities/User.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { RequireRoles } from "../utils/decorators/RequireRoles.js";
import {
    createProfileEmbed,
    createErrorEmbed
} from "../utils/embedBuilder.js";
import {
    getMaxLevelForExp,
    calculateNextLevelExp,
    getExpToNextLevel,
    getProgressToNextLevel,
    isMaxLevel
} from "../utils/levelUpUtils.js";
import logger from "../services/logger.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";

@Discord()
class ModProfileCommand {
    @Slash({ 
        description: "–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        defaultMemberPermissions: "0", 
        dmPermission: false, 
    })
    @EnsureUser()
    @Guard(
        EnsureUserGuard(),
        RequireRoles(["high_mod_level", "medium_mod_level"])
    )
    async modprofile(
        @SlashOption({
            name: "user",
            description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–æ—Ñ–∏–ª—è",
            type: ApplicationCommandOptionType.User,
            required: false
        })
        user: User | undefined,
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();
            const targetUser = user ? await interaction.client.users.fetch(user.id) : interaction.user;
            const userRepository = AppDataSource.getRepository(DBUser);

            const dbUser = await userRepository.findOne({
                where: { discordId: targetUser.id },
                relations: ["exp", "currency"]
            });

            const messageCount = dbUser?.messageCount ?? BigInt(0);
            const voiceMinutes = dbUser?.voiceMinutes ?? BigInt(0);
            const expValue = dbUser?.exp?.exp ?? BigInt(0);

            let levelValue = dbUser?.exp?.level ?? 1;
            const calculatedLevel = getMaxLevelForExp(expValue);

            if (levelValue !== calculatedLevel && dbUser?.exp) {
                levelValue = calculatedLevel;
                dbUser.exp.level = levelValue;
                await AppDataSource.getRepository(dbUser.exp.constructor).save(dbUser.exp);
                logger.info(`–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetUser.id}: ${levelValue}`);
            }

            const currencyValue = dbUser?.currency?.currencyCount ?? BigInt(0);

            const embed = createProfileEmbed(
                targetUser,
                messageCount,
                voiceMinutes,
                expValue,
                levelValue,
                currencyValue,
                interaction.user
            );

            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ profile:", error);
        }
    }
}

export default ModProfileCommand;


# ./src/commands/treeSkills.ts.old
import { Discord, Slash, Guard } from "discordx";
import { CommandInteraction, AttachmentBuilder } from "discord.js";
import { Cooldown } from "../utils/decorators/CoommandCooldown.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { generateBasicSkillTreeImage, generateDemoSkills } from "../utils/drawSkillTree.js";
import logger from "../services/logger.js";

@Discord()
export class SkillTreeCommand {
    @Slash({
        name: "skilltree",
        description: "–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤"
    })
    @Guard(
        ChannelGuard("user_commands_channel"),
        Cooldown({ seconds: 10 })
    )
    async skilltree(interaction: CommandInteraction): Promise<void> {
        try {
            // –°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ
            await interaction.deferReply();
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞–≤—ã–∫–æ–≤ —Å–æ–≥–ª–∞—Å–Ω–æ –æ–ø–∏—Å–∞–Ω–∏—é
            const skillsData = generateDemoSkills();
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –¥–µ—Ä–µ–≤–æ–º –Ω–∞–≤—ã–∫–æ–≤
            const imageBuffer = await generateBasicSkillTreeImage(skillsData);
            
            // –°–æ–∑–¥–∞–µ–º –≤–ª–æ–∂–µ–Ω–∏–µ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
            const attachment = new AttachmentBuilder(imageBuffer, { name: 'skill-tree.png' });
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await interaction.editReply({
                content: 'üå≥ –í–æ—Ç –≤–∞—à–µ –¥–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤:\n–í –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –≤—ã —Å–º–æ–∂–µ—Ç–µ –ø—Ä–æ–∫–∞—á–∏–≤–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –Ω–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏.',
                files: [attachment]
            });
            
            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${interaction.user.tag} –∑–∞–ø—Ä–æ—Å–∏–ª –¥–µ—Ä–µ–≤–æ –Ω–∞–≤—ã–∫–æ–≤`);
        } catch (error) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
            logger.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤:', error);
            
            await interaction.editReply({
                content: '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–µ—Ä–µ–≤–∞ –Ω–∞–≤—ã–∫–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
            });
        }
    }
}

# ./src/commands/duelCommands.ts
import { Discord, Slash, SlashOption, Guard, ButtonComponent } from "discordx";
import { CommandInteraction, ButtonInteraction, ButtonBuilder, ButtonStyle, ActionRowBuilder, ApplicationCommandOptionType, User, EmbedBuilder } from "discord.js";
import { CheckMoney } from "../utils/decorators/CheckMoney.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { Cooldown } from "../utils/decorators/CoommandCooldown.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { createDuelEmbed } from "../utils/embedBuilder.js";
import { AppDataSource } from "../services/database.js";
import { Currency } from "../entities/Currency.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";
import { Config } from "../entities/Config.js";

@Discord()
export class DuelCommand {
    private static duelTimeouts: Map<string, NodeJS.Timeout> = new Map();

    @Slash({ description: "–ù–∞—á–∞—Ç—å –¥—É—ç–ª—å", name: "duel" })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        CheckMoney(),
        Cooldown({ seconds: 30 }),
        EnsureUserGuard()
    )
    async startDuel(
        @SlashOption({
            name: "bet",
            description: "–°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏",
            type: ApplicationCommandOptionType.Number,
            required: true,
            minValue: 250,
            maxValue: 1500
        })
        bet: number,
        @SlashOption({
            name: "opponent",
            description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–∑–≤–∞—Ç—å –Ω–∞ –¥—É—ç–ª—å",
            type: ApplicationCommandOptionType.User,
            required: false
        })
        opponent: User | undefined,
        interaction: CommandInteraction
    ) {
        try {
            if (opponent?.id === interaction.user.id) {
                await interaction.reply({
                    content: "‚ùå –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –≤—ã–∑–≤–∞—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—è –Ω–∞ –¥—É—ç–ª—å.",
                    ephemeral: true
                });
                return;
            }

            const expireTimestamp = Math.floor(Date.now() / 1000) + 30;
            const customId = `duel_${interaction.user.id}_${bet}_${expireTimestamp}_${opponent?.id ?? "any"}`;

            const btn = new ButtonBuilder()
                .setCustomId(customId)
                .setLabel("–ü—Ä–∏–Ω—è—Ç—å –≤—ã–∑–æ–≤")
                .setStyle(ButtonStyle.Primary);

            const row = new ActionRowBuilder<ButtonBuilder>().addComponents(btn);

            const embed = createDuelEmbed(
                bet,
                interaction.user,
                opponent,
                undefined,
                undefined,
                expireTimestamp
            );

            const message = await interaction.reply({
                embeds: [embed],
                components: [row]
            });

            const configRepository = AppDataSource.getRepository(Config);
            const configs = await configRepository.findBy(["user_commands_channel"].map(key => ({ key })));
            const commandsChannelId = configs.find(c => c.key === "user_commands_channel")?.value;
            const replyMessage = await interaction.fetchReply();

            if (opponent) {
                try {
                    await opponent.send({
                        content: `üé≤ ${interaction.user.tag} –≤—ã–∑–≤–∞–ª —Ç–µ–±—è –Ω–∞ –¥—É—ç–ª—å —Å —Å—Ç–∞–≤–∫–æ–π **${bet}**! –ü—Ä–∏–º–∏ –≤—ã–∑–æ–≤: ${replyMessage.url})`
                    });
                } catch (dmError) {
                    console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –õ–° ${opponent.tag}:`, dmError);
                    if (commandsChannelId) {
                        const channel = await interaction.guild?.channels.fetch(commandsChannelId);
                        if (channel?.isTextBased()) {
                            await channel.send({
                                content: `${opponent}, ${interaction.user} –≤—ã–∑–≤–∞–ª —Ç–µ–±—è –Ω–∞ –¥—É—ç–ª—å!`,
                                allowedMentions: { users: [opponent.id] }
                            });
                        }
                    }
                }
            }
            const timeout = setTimeout(async () => {
                try {
                    await replyMessage.edit({
                        embeds: [createDuelEmbed(
                            bet,
                            interaction.user,
                            opponent,
                            undefined,
                            undefined,
                            expireTimestamp,
                            true
                        )],
                        components: []
                    });
                } catch (err) {
                    console.error("Error updating expired duel:", err);
                }
              DuelCommand.duelTimeouts.delete(interaction.user.id);
            }, 30000);

          DuelCommand.duelTimeouts.set(interaction.user.id, timeout);
        } catch (error) {
            console.error("Duel command error:", error);
            await interaction.reply({
                content: "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥—É—ç–ª–∏",
                ephemeral: true
            });
        }
    }
    

    @ButtonComponent({ id: /duel_\d+_\d+_\d+_(\d+|any)/ })
    @Guard(
      CheckMoney(),
      EnsureUserGuard()
    )
    async acceptDuel(interaction: ButtonInteraction) {
      try {
        const [_, creatorId, betStr, timestampStr, opponentId] = interaction.customId.split("_");
        const bet = parseInt(betStr, 10);
    
        if (interaction.user.id === creatorId) {
          await interaction.reply({
            content: "‚ùå –ù–µ–ª—å–∑—è –ø—Ä–∏–Ω—è—Ç—å —Å–≤–æ–π –∂–µ –≤—ã–∑–æ–≤.",
            ephemeral: true
          });
          return;
        }
    
        if (opponentId !== "any" && interaction.user.id !== opponentId) {
          await interaction.reply({
            content: "‚ùå –≠—Ç–∞ –¥—É—ç–ª—å –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.",
            ephemeral: true
          });
          return;
        }
    
        const timeout = DuelCommand.duelTimeouts.get(creatorId);
        if (timeout) {
          clearTimeout(timeout);
          DuelCommand.duelTimeouts.delete(creatorId);
        }
    
        const creatorUser = await interaction.client.users.fetch(creatorId);
        const winner = Math.random() > 0.5 ? interaction.user : creatorUser;
        const loser = winner.id === interaction.user.id ? creatorUser : interaction.user;
        const winAmount = Math.floor((bet * 2 * 0.97) - bet);
    
        const currencyRepo = AppDataSource.getRepository(Currency);
        const [winnerCurrency, loserCurrency] = await Promise.all([
          currencyRepo.findOne({ where: { user: { discordId: winner.id } } }),
          currencyRepo.findOne({ where: { user: { discordId: loser.id } } })
        ]);
    
        if (!winnerCurrency || !loserCurrency) {
          throw new Error("Currency not found");
        }
    
        await currencyRepo.manager.transaction(async manager => {
          winnerCurrency.currencyCount += BigInt(winAmount);
          loserCurrency.currencyCount -= BigInt(bet);
          await manager.save([winnerCurrency, loserCurrency]);
        });
    
        await interaction.message.edit({
          embeds: [
            createDuelEmbed(
              bet,
              creatorUser,
              loser,
              winAmount,
              winner
            )
          ],
          components: []
        });
    
        await interaction.deferUpdate();
      } catch (error) {
        console.error("Duel accept error:", error);
        await interaction.reply({
          content: "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è –¥—É—ç–ª–∏",
          ephemeral: true
        });
      }
    }
    
}



# ./src/commands/profile.ts
import { Discord, Slash, SlashOption, Guard } from "discordx";
import { CommandInteraction, User, ApplicationCommandOptionType, AttachmentBuilder } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User as DBUser } from "../entities/User.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { WithCustomBackground } from "../utils/decorators/CustomBackgroundDecorator.js";
import { createErrorEmbed } from "../utils/embedBuilder.js";
import {
    calculateNextLevelExp,
    getMaxLevelForExp,
    getProgressToNextLevel,
    isMaxLevel
} from "../utils/levelUpUtils.js";
import { generateProfileImage } from "../utils/profileImageGenerator.js";
import logger from "../services/logger.js";
import { Config } from "../entities/Config.js";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";

@Discord()
class ProfileCommand {
    @Slash({ description: "–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è" })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async profile(
        @SlashOption({
            name: "user",
            description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–æ—Ñ–∏–ª—è",
            type: ApplicationCommandOptionType.User,
            required: false
        })
        user: User | undefined,
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();

            const targetUser = user ? await interaction.client.users.fetch(user.id) : interaction.user;
            logger.info(`Generating profile for user: ${targetUser.tag} (${targetUser.id})`);

            const userRepository = AppDataSource.getRepository(DBUser);
            const dbUser = await userRepository.findOne({
                where: { discordId: targetUser.id },
                relations: ["exp", "currency"]
            });

            const messageCount = dbUser?.messageCount ?? BigInt(0);
            const voiceMinutes = dbUser?.voiceMinutes ?? BigInt(0);
            const expValue = dbUser?.exp?.exp ?? BigInt(0);
            const currencyValue = dbUser?.currency?.currencyCount ?? BigInt(0);

            let levelValue = dbUser?.exp?.level ?? 1;
            const calculatedLevel = getMaxLevelForExp(expValue);

            if (levelValue !== calculatedLevel && dbUser?.exp) {
                levelValue = calculatedLevel;
                dbUser.exp.level = levelValue;
                await AppDataSource.getRepository(dbUser.exp.constructor).save(dbUser.exp);
                logger.info(`–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetUser.id}: ${levelValue}`);
            }
            const nextLevelExp = calculateNextLevelExp(levelValue);
            let progressPercentage = 0;
            if (!isMaxLevel(levelValue)) {
                progressPercentage = Number((Number(expValue) / Number(nextLevelExp) * 100).toFixed(1));
            }

            logger.info(`User stats - Messages: ${messageCount}, Voice: ${voiceMinutes}, Level: ${levelValue}, Progress: ${progressPercentage}%`);

            let backgroundImagePath = undefined;
                try {
                    const configRepo = AppDataSource.getRepository(Config);
                    const config = await configRepo.findOne({
                        where: { key: "custom_background", value: targetUser.id }
                    });
                    
                    if (config) {
                        const __filename = fileURLToPath(import.meta.url);
                        const __dirname = path.dirname(__filename);
                        const imagePath = path.join(__dirname, '../../assets/images', `${targetUser.id}.png`);
                        
                        if (fs.existsSync(imagePath)) {
                            backgroundImagePath = imagePath;
                            logger.info(`–ü—Ä–∏–º–µ–Ω—è–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetUser.id}`);
                        }
                    }
                } catch (error) {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞: ${error}`);
                }

            try {
                const profileImage = await generateProfileImage(
                    targetUser,
                    Number(messageCount),
                    Number(voiceMinutes),
                    levelValue,
                    Number(currencyValue),
                    progressPercentage,
                    backgroundImagePath
                );

                const attachment = new AttachmentBuilder(profileImage, { name: 'profile.png' });
                await interaction.editReply({ files: [attachment] });
                logger.info(`Profile image sent successfully for ${targetUser.tag}`);
            } catch (imageError) {
                logger.error(`Error generating profile image: ${imageError}`);
                const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è", interaction.user);
                await interaction.editReply({ embeds: [errorEmbed] });
            }
        } catch (error) {
            logger.error(`General error in profile command: ${error}`);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö", interaction.user);
            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }
}

export default ProfileCommand;

# ./src/commands/casinoCommand.ts
import { Discord, Slash, SlashOption, Guard, ButtonComponent, SlashGroup } from "discordx";
import { CommandInteraction, ApplicationCommandOptionType, Message, ButtonBuilder, ActionRowBuilder, ButtonStyle } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User as DBUser } from "../entities/User.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { createErrorEmbed, createCasinoResultEmbed } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { Currency } from "../entities/Currency.js";
import { Cooldown } from "../utils/decorators/CoommandCooldown.js";
import { determineCasinoResult } from "../utils/casinoUtils.js";
import { CheckMoney } from "../utils/decorators/CheckMoney.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";
import { BlackjackGame, GameState } from "../utils/blackjackUtils.js";

@Discord()
@SlashGroup({
    description: "–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∏–≥—Ä—ã –≤ –∫–∞–∑–∏–Ω–æ",
    name: "casino",
    dmPermission: false,
})
@SlashGroup("casino")
class CasinoCommands {
    private static TAX_RATE: number;

    @Slash({
        name: "random",
        description: "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–≤–æ—é —É–¥–∞—á—É –≤ –∫–∞–∑–∏–Ω–æ"
    })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        CheckMoney(),
        EnsureUserGuard(),
        Cooldown({ minutes: 1 })
    )
    async random(
        @SlashOption({
            name: "bet",
            description: "–†–∞–∑–º–µ—Ä —Å—Ç–∞–≤–∫–∏ (–æ—Ç 1000 –¥–æ 10000)",
            type: ApplicationCommandOptionType.Integer,
            required: true,
            minValue: 1000,
            maxValue: 10000
        })
        bet: number,
        interaction: CommandInteraction
    ) {
        try {
            if (!interaction || !interaction.user) {
                logger.error("Casino random: Invalid interaction");
                return;
            }

            if (isNaN(bet) || bet === null || bet === undefined) {
                logger.error("Casino random: Invalid bet value", bet);

                if (!interaction.replied && !interaction.deferred) {
                    const errorEmbed = createErrorEmbed("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞", interaction.user);
                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
                }
                return;
            }

            if (!interaction.replied && !interaction.deferred) {
                await interaction.deferReply();
            }

            const discordUser = interaction.user;

            const dbUser = await AppDataSource.getRepository(DBUser).findOneOrFail({
                where: { discordId: discordUser.id },
                relations: ["currency"]
            });

            const currencyRepository = AppDataSource.getRepository(Currency);

            if (dbUser.currency.currencyCount < BigInt(bet)) {
                const errorEmbed = createErrorEmbed(
                    `–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤! –ù–µ–æ–±—Ö–æ–¥–∏–º–æ ${bet}$, —É –≤–∞—Å ${dbUser.currency.currencyCount}$`,
                    interaction.user
                );

                if (interaction.deferred) {
                    await interaction.editReply({ embeds: [errorEmbed] });
                } else if (!interaction.replied) {
                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
                }
                return;
            }

            await AppDataSource.transaction(async (transactionalEntityManager) => {
                const newBalance = dbUser.currency.currencyCount - BigInt(bet);
                await transactionalEntityManager.update(Currency,
                    { id: dbUser.currency.id },
                    { currencyCount: newBalance }
                );

                const result = determineCasinoResult();
                const winAmount = Math.floor(bet * result.multiplier);
                let tax = 0;
                let netWin = winAmount;

                if (winAmount > 0) {
                    tax = Math.floor(winAmount * (CasinoCommands.TAX_RATE || 0.1));
                    netWin = winAmount - tax;

                    await transactionalEntityManager.update(Currency,
                        { id: dbUser.currency.id },
                        { currencyCount: newBalance + BigInt(netWin) }
                    );
                }

                const embed = createCasinoResultEmbed(
                    bet,
                    netWin,
                    result,
                    interaction
                );

                logger.info(
                    `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordUser.id} —Å–¥–µ–ª–∞–ª —Å—Ç–∞–≤–∫—É ${bet}$ ` +
                    `–≤ –∫–∞–∑–∏–Ω–æ –∏ ${winAmount > 0 ? `–≤—ã–∏–≥—Ä–∞–ª ${netWin}$ (–Ω–∞–ª–æ–≥ ${tax}$)` : '–ø—Ä–æ–∏–≥—Ä–∞–ª'}`
                );

                if (interaction.deferred) {
                    await interaction.editReply({ embeds: [embed] });
                } else if (!interaction.replied) {
                    await interaction.reply({ embeds: [embed] });
                }
            });

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ –∫–∞–∑–∏–Ω–æ:", error);

            try {
                const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç–∞–≤–∫–∏", interaction.user);

                if (interaction.deferred) {
                    await interaction.editReply({ embeds: [errorEmbed] });
                } else if (!interaction.replied) {
                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
                }
            } catch (responseError) {
                logger.error("Failed to send error response in casino command:", responseError);
            }
        }
    }

    private static activeGames = new Map<string, GameState & { message?: Message }>();

    private static game = new BlackjackGame();

    @Slash({ name: "blackjack", description: "–ò–≥—Ä–∞ –≤ 21 (Blackjack)" })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        CheckMoney(),
        EnsureUserGuard(),
        Cooldown({ minutes: 1 })
    )
    async blackjack(
        @SlashOption({
            name: "bet",
            description: "–†–∞–∑–º–µ—Ä —Å—Ç–∞–≤–∫–∏ (–æ—Ç 500 –¥–æ 5000)",
            type: ApplicationCommandOptionType.Integer,
            required: true,
            minValue: 500,
            maxValue: 5000
        })
        bet: number,
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();
            const userId = interaction.user.id;

            if (CasinoCommands.activeGames.has(userId)) {
                await interaction.editReply({
                    embeds: [createErrorEmbed(
                        "–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è –∏–≥—Ä–∞! –ó–∞–≤–µ—Ä—à–∏—Ç–µ —Ç–µ–∫—É—â—É—é –∏–≥—Ä—É –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –Ω–æ–≤–æ–π.",
                        interaction.user
                    )]
                });
                return;
            }

            const dbUser = await AppDataSource.getRepository(DBUser).findOneOrFail({
                where: { discordId: userId },
                relations: ["currency"]
            });

            const currencyRepository = AppDataSource.getRepository(Currency);
            await currencyRepository.update(
                { id: dbUser.currency.id },
                { currencyCount: dbUser.currency.currencyCount - BigInt(bet) }
            );

            const deck = CasinoCommands.game.createDeck();
            const gameState: GameState & { message?: Message } = {
                playerCards: [deck.pop()!, deck.pop()!],
                dealerCards: [deck.pop()!, deck.pop()!],
                bet,
                playerTurn: true,
                deck
            };

            const embed = CasinoCommands.game.createGameEmbed(gameState, interaction.user);
            const buttons = new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                    .setCustomId("hit")
                    .setLabel("–í–∑—è—Ç—å –∫–∞—Ä—Ç—É")
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId("stand")
                    .setLabel("–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è")
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId("double")
                    .setLabel("–£–¥–≤–æ–∏—Ç—å")
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId("surrender")
                    .setLabel("–°–¥–∞—Ç—å—Å—è")
                    .setStyle(ButtonStyle.Danger)
            ) as ActionRowBuilder<ButtonBuilder>;

            const message = await interaction.editReply({
                embeds: [embed],
                components: [buttons]
            }) as Message;

            gameState.message = message;
            CasinoCommands.activeGames.set(userId, gameState);

            logger.info(`Blackjack: –ò–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞ –¥–ª—è ${userId}, —Å—Ç–∞–≤–∫–∞ ${bet}$`);

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ Blackjack:", error);
            await interaction.editReply({
                embeds: [createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã", interaction.user)]
            });
        }
    }

    @ButtonComponent({ id: "hit" })
    async hitButton(interaction: any) {
        try {
            await interaction.deferUpdate();
            const userId = interaction.user.id;
            const gameState = CasinoCommands.activeGames.get(userId);

            if (!gameState || !gameState.playerTurn) {
                await interaction.followUp({
                    content: "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥!",
                    ephemeral: true
                });
                return;
            }

            gameState.playerCards.push(gameState.deck.pop()!);

            if (CasinoCommands.game.calculateHand(gameState.playerCards) > 21) {
                const { embed } = await CasinoCommands.game.dealerTurn(gameState, interaction.user);
                const result = await CasinoCommands.game.processGameResult(gameState, userId);

                await gameState.message?.edit({
                    embeds: [embed],
                    components: []
                });

                logger.info(
                    `Blackjack: –ò–≥—Ä–æ–∫ ${userId} –ø–µ—Ä–µ–±—Ä–∞–ª, —Å—Ç–∞–≤–∫–∞ ${gameState.bet}$` +
                    (result.winAmount > 0 ? `, –≤—ã–∏–≥—Ä—ã—à ${result.winAmount}$` : "")
                );

                CasinoCommands.activeGames.delete(userId);
                return;
            }

            const embed = CasinoCommands.game.createGameEmbed(gameState, interaction.user);
            await gameState.message?.edit({ embeds: [embed] });

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ HIT:", error);
        }
    }

    @ButtonComponent({ id: "stand" })
    async standButton(interaction: any) {
        try {
            await interaction.deferUpdate();
            const userId = interaction.user.id;
            const gameState = CasinoCommands.activeGames.get(userId);

            if (!gameState || !gameState.playerTurn) {
                await interaction.followUp({
                    content: "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥!",
                    ephemeral: true
                });
                return;
            }

            const { embed } = await CasinoCommands.game.dealerTurn(gameState, interaction.user);
            const result = await CasinoCommands.game.processGameResult(gameState, userId);

            await gameState.message?.edit({
                embeds: [embed],
                components: []
            });

            logger.info(
                `Blackjack: –ò–≥—Ä–æ–∫ ${userId} –∑–∞–≤–µ—Ä—à–∏–ª –∏–≥—Ä—É, —Å—Ç–∞–≤–∫–∞ ${gameState.bet}$` +
                (result.winAmount > 0 ? `, –≤—ã–∏–≥—Ä—ã—à ${result.winAmount}$` : "") +
                `, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${result.result}`
            );

            CasinoCommands.activeGames.delete(userId);

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ STAND:", error);
        }
    }

    @ButtonComponent({ id: "double" })
    async doubleButton(interaction: any) {
        try {
            await interaction.deferUpdate();
            const userId = interaction.user.id;
            const gameState = CasinoCommands.activeGames.get(userId);

            if (!gameState || !gameState.playerTurn) {
                await interaction.followUp({
                    content: "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥!",
                    ephemeral: true
                });
                return;
            }

            if (gameState.playerCards.length !== 2) {
                await interaction.followUp({
                    content: "–£–¥–≤–æ–µ–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–µ—Ä–≤—ã—Ö –¥–≤—É—Ö –∫–∞—Ä—Ç–∞—Ö!",
                    ephemeral: true
                });
                return;
            }

            const dbUser = await AppDataSource.getRepository(DBUser).findOneOrFail({
                where: { discordId: userId },
                relations: ["currency"]
            });

            if (dbUser.currency.currencyCount < BigInt(gameState.bet)) {
                await interaction.followUp({
                    content: `–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è —É–¥–≤–æ–µ–Ω–∏—è! –ù—É–∂–Ω–æ –µ—â–µ ${gameState.bet}$`,
                    ephemeral: true
                });
                return;
            }

            const currencyRepository = AppDataSource.getRepository(Currency);
            await currencyRepository.update(
                { id: dbUser.currency.id },
                { currencyCount: dbUser.currency.currencyCount - BigInt(gameState.bet) }
            );

            gameState.bet *= 2;

            gameState.playerCards.push(gameState.deck.pop()!);

            const { embed } = await CasinoCommands.game.dealerTurn(gameState, interaction.user);
            const result = await CasinoCommands.game.processGameResult(gameState, userId);

            await gameState.message?.edit({
                embeds: [embed],
                components: []
            });

            logger.info(
                `Blackjack: –ò–≥—Ä–æ–∫ ${userId} —É–¥–≤–æ–∏–ª —Å—Ç–∞–≤–∫—É –¥–æ ${gameState.bet}$` +
                (result.winAmount > 0 ? `, –≤—ã–∏–≥—Ä—ã—à ${result.winAmount}$` : "") +
                `, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${result.result}`
            );

            CasinoCommands.activeGames.delete(userId);

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ DOUBLE:", error);
        }
    }

    @ButtonComponent({ id: "surrender" })
    async surrenderButton(interaction: any) {
        try {
            await interaction.deferUpdate();
            const userId = interaction.user.id;
            const gameState = CasinoCommands.activeGames.get(userId);

            if (!gameState || !gameState.playerTurn) {
                await interaction.followUp({
                    content: "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∏–≥—Ä—ã –∏–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥!",
                    ephemeral: true
                });
                return;
            }

            const { winAmount } = await CasinoCommands.game.processGameResult(gameState, userId, true);
            const embed = CasinoCommands.game.createGameEmbed(gameState, interaction.user, true);
            embed.setDescription(`**–í—ã —Å–¥–∞–ª–∏—Å—å! –í–æ–∑–≤—Ä–∞—â–µ–Ω–æ ${winAmount}$.**`);

            await gameState.message?.edit({
                embeds: [embed],
                components: []
            });

            logger.info(
                `Blackjack: –ò–≥—Ä–æ–∫ ${userId} —Å–¥–∞–ª—Å—è, –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ ${winAmount}$ –∏–∑ —Å—Ç–∞–≤–∫–∏ ${gameState.bet}$`
            );

            CasinoCommands.activeGames.delete(userId);

        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ SURRENDER:", error);
        }
    }
}

export default CasinoCommands;


# ./src/commands/configCommands.ts
import { Discord, SlashGroup, Slash, SlashOption, SlashChoice, Guard } from "discordx";
import { CommandInteraction, ApplicationCommandOptionType, Attachment } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { Config } from "../entities/Config.js";
import { RequireRoles } from "../utils/decorators/RequireRoles.js";
import { createSuccessEmbed, createErrorEmbed, createEmbed, EmbedColors } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
import axios from "axios";

@Discord()
@SlashGroup({
    description: "–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞",
    name: "config",
    defaultMemberPermissions: "0",
    dmPermission: false,
})
@SlashGroup("config")
class ConfigCommands {
    @Slash({ description: "–î–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ñ–∏–≥" })
    @Guard(RequireRoles(["high_mod_level", "medium_mod_level"]))
    async add(
        @SlashChoice({ name: "Low Moderation Level", value: "low_mod_level" })
        @SlashChoice({ name: "Medium Moderation Level", value: "medium_mod_level" })
        @SlashChoice({ name: "High Moderation Level", value: "high_mod_level" })
        @SlashChoice({ name: "Ignore Voice Channel For EXP", value: "ignore_voice_channel_exp" })
        @SlashChoice({ name: "Allow chat commands for users ", value: "user_commands_channel" })
        @SlashChoice({ name: "Gallery chat for reactions", value: "gallery_chat" })
        @SlashChoice({ name: "Chat ID for logs messages", value: "log_chat" })
        @SlashChoice({ name: "Chat ID for giving roles", value: "give_role_chat" })
        @SlashChoice({ name: "Role ID for give to user", value: "give_role_id" })
        @SlashChoice({ name: "Role description", value: "role_description" })
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª—é—á –∫–æ–Ω—Ñ–∏–≥–∞",
            name: "key",
            required: true,
            type: ApplicationCommandOptionType.String
        })
        key: string,
        @SlashOption({
            description: "–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –∫–ª—é—á–∞",
            name: "value",
            required: true,
            type: ApplicationCommandOptionType.String
        })
        value: string,
        interaction: CommandInteraction
    ) {
        try {
            const configRepository = AppDataSource.getRepository(Config);

            if (key === "role_description") {
                const parts = value.split(":", 2);
                if (parts.length !== 2 || !parts[0] || !parts[1]) {
                    const embed = createErrorEmbed(
                        "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –î–ª—è –æ–ø–∏—Å–∞–Ω–∏—è —Ä–æ–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç 'roleId:–æ–ø–∏—Å–∞–Ω–∏–µ'",
                        interaction.user
                    );
                    return interaction.reply({ embeds: [embed] });
                }

                const roleId = parts[0];
                const description = parts[1];

                const role = interaction.guild?.roles.cache.get(roleId);
                if (!role) {
                    const embed = createErrorEmbed(
                        `–†–æ–ª—å —Å ID ${roleId} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ`,
                        interaction.user
                    );
                    return interaction.reply({ embeds: [embed] });
                }

                const existingRole = await configRepository.findOne({
                    where: { key: "give_role_id", value: roleId }
                });

                if (!existingRole) {
                    const embed = createErrorEmbed(
                        `–†–æ–ª—å ${role.name} –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è –≤—ã–¥–∞—á–∏. –°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –µ—ë —á–µ—Ä–µ–∑ /config add key:give_role_id value:${roleId}`,
                        interaction.user
                    );
                    return interaction.reply({ embeds: [embed] });
                }

                if (description.length > 100) {
                    const embed = createErrorEmbed(
                        "–û–ø–∏—Å–∞–Ω–∏–µ —Ä–æ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (–±–æ–ª–µ–µ 100 —Å–∏–º–≤–æ–ª–æ–≤). –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–∫—Ä–∞—Ç–∏—Ç–µ –µ–≥–æ.",
                        interaction.user
                    );
                    return interaction.reply({ embeds: [embed] });
                }

                const existingDescs = await configRepository.find({
                    where: { key: "role_description" }
                });

                const existingDesc = existingDescs.find(config =>
                    config.value.startsWith(`${roleId}:`)
                );

                if (existingDesc) {
                    await configRepository.delete(existingDesc.id);
                    logger.info(`–£–¥–∞–ª–µ–Ω–æ —Å—Ç–∞—Ä–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–æ–ª–∏ ${role.name}`);
                }
            }

            const newConfig = configRepository.create({ key, value });
            await configRepository.save(newConfig);
            logger.info(`–î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥ ${key} = ${value}`);

            const embed = createSuccessEmbed(`–ö–æ–Ω—Ñ–∏–≥ **${key}** —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: \`${value}\``, interaction.user);
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞:", error);

            const embed = createErrorEmbed("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞", interaction.user);
            await interaction.reply({ embeds: [embed] });
        }
    }

    @Slash({ description: "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –ø—Ä–æ—Ñ–∏–ª—è" })
    @Guard(RequireRoles(["high_mod_level"]))
    async setbackground(
        @SlashOption({
            description: "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ñ–æ–Ω–∞ –ø—Ä–æ—Ñ–∏–ª—è (PNG)",
            name: "image",
            required: true,
            type: ApplicationCommandOptionType.Attachment
        })
        attachment: Attachment,
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();

            const userId = interaction.user.id;

            if (!attachment.contentType?.startsWith('image/')) {
                const embed = createErrorEmbed("–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º.", interaction.user);
                return interaction.editReply({ embeds: [embed] });
            }

            const __filename = fileURLToPath(import.meta.url);
            const __dirname = path.dirname(__filename);
            const assetsPath = path.join(__dirname, '../../assets/images');
            const customBackgroundFullPath = path.join(assetsPath, `${userId}.png`);

            if (!fs.existsSync(assetsPath)) {
                fs.mkdirSync(assetsPath, { recursive: true });
                logger.info(`–°–æ–∑–¥–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: ${assetsPath}`);
            }

            const response = await axios.get(attachment.url, { responseType: 'arraybuffer' });
            fs.writeFileSync(customBackgroundFullPath, Buffer.from(response.data));
            logger.info(`–§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: ${customBackgroundFullPath}`);

            const configRepository = AppDataSource.getRepository(Config);
            const existingConfig = await configRepository.findOne({
                where: { key: "custom_background", value: userId }
            });

            if (!existingConfig) {
                const newConfig = configRepository.create({ key: "custom_background", value: userId });
                await configRepository.save(newConfig);
                logger.info(`–î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥ custom_background = ${userId}`);
            }

            const embed = createSuccessEmbed(
                `–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –≤–∞—à–µ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è!`,
                interaction.user
            );
            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞:", error);
            const embed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞.", interaction.user);
            await interaction.editReply({ embeds: [embed] });
        }
    }

    @Slash({ description: "–£–±—Ä–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –ø—Ä–æ—Ñ–∏–ª—è" })
    @Guard(RequireRoles(["high_mod_level"]))
    async removebackground(
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();
            const userId = interaction.user.id;

            const __filename = fileURLToPath(import.meta.url);
            const __dirname = path.dirname(__filename);
            const assetsPath = path.join(__dirname, '../../assets/images');
            const customBackgroundFullPath = path.join(assetsPath, `${userId}.png`);

            let fileDeleted = false;
            if (fs.existsSync(customBackgroundFullPath)) {
                fs.unlinkSync(customBackgroundFullPath);
                fileDeleted = true;
                logger.info(`–£–¥–∞–ª–µ–Ω —Ñ–∞–π–ª —Ñ–æ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}: ${customBackgroundFullPath}`);
            }

            const configRepository = AppDataSource.getRepository(Config);
            const result = await configRepository.delete({
                key: "custom_background",
                value: userId
            });

            if (result.affected === 0 && !fileDeleted) {
                const embed = createErrorEmbed(`–£ –≤–∞—Å –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω.`, interaction.user);
                return interaction.editReply({ embeds: [embed] });
            }

            logger.info(`–£–¥–∞–ª–µ–Ω –∫–æ–Ω—Ñ–∏–≥ custom_background –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
            const embed = createSuccessEmbed(
                `–ö–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –≤–∞—à–µ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è —É–¥–∞–ª–µ–Ω.`,
                interaction.user
            );
            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞:", error);
            const embed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Ñ–æ–Ω–∞.", interaction.user);
            await interaction.editReply({ embeds: [embed] });
        }
    }

    @Slash({ description: "–£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–∞" })
    @Guard(RequireRoles(["high_mod_level", "medium_mod_level"]))
    async remove(
        @SlashChoice({ name: "Low Moderation Level", value: "low_mod_level" })
        @SlashChoice({ name: "Medium Moderation Level", value: "medium_mod_level" })
        @SlashChoice({ name: "High Moderation Level", value: "high_mod_level" })
        @SlashChoice({ name: "Ignore Voice Channel For EXP", value: "ignore_voice_channel_exp" })
        @SlashChoice({ name: "Allow chat commands for users ", value: "user_commands_channel" })
        @SlashChoice({ name: "Custom Background For Profile", value: "custom_background" })
        @SlashChoice({ name: "Gallery chat for reactions", value: "gallery_chat" })
        @SlashChoice({ name: "Chat ID for logs messages", value: "log_chat" })
        @SlashChoice({ name: "Chat ID for giving roles", value: "give_role_chat" })
        @SlashChoice({ name: "Role ID for give to user", value: "give_role_id" })
        @SlashChoice({ name: "Role description", value: "role_description" })
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª—é—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è",
            name: "key",
            required: true,
            type: ApplicationCommandOptionType.String
        })
        key: string,
        @SlashOption({
            description: "–í–ø–∏—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª—é—á–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è",
            name: "value",
            required: true,
            type: ApplicationCommandOptionType.String
        })
        value: string,
        interaction: CommandInteraction
    ) {
        try {
            const configRepository = AppDataSource.getRepository(Config);

            if (key === "role_description") {
                if (!value.includes(":")) {
                    const roleId = value;

                    const existingDescs = await configRepository.find({
                        where: { key: "role_description" }
                    });

                    const existingDesc = existingDescs.find(config =>
                        config.value.startsWith(`${roleId}:`)
                    );

                    if (!existingDesc) {
                        const embed = createErrorEmbed(`–û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–æ–ª–∏ —Å ID ${roleId} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ`, interaction.user);
                        return interaction.reply({ embeds: [embed] });
                    }

                    await configRepository.delete(existingDesc.id);
                    logger.info(`–£–¥–∞–ª–µ–Ω–æ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–æ–ª–∏ —Å ID ${roleId}`);

                    const embed = createSuccessEmbed(`–û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–æ–ª–∏ —Å ID ${roleId} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ`, interaction.user);
                    await interaction.reply({ embeds: [embed] });
                    return;
                }
            }

            const result = await configRepository.delete({ key, value });

            if (result.affected === 0) {
                const embed = createErrorEmbed(`–ö–æ–Ω—Ñ–∏–≥ **${key}** **${value}** –Ω–µ –Ω–∞–π–¥–µ–Ω`, interaction.user);
                return interaction.reply({ embeds: [embed] });
            }

            if (key === "custom_background") {
                try {
                    const __filename = fileURLToPath(import.meta.url);
                    const __dirname = path.dirname(__filename);
                    const assetsPath = path.join(__dirname, '../../assets/images');
                    const customBackgroundFullPath = path.join(assetsPath, `${value}.png`);

                    if (fs.existsSync(customBackgroundFullPath)) {
                        fs.unlinkSync(customBackgroundFullPath);
                        logger.info(`–£–¥–∞–ª–µ–Ω —Ñ–∞–π–ª —Ñ–æ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${value}: ${customBackgroundFullPath}`);
                    }
                } catch (fileError) {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ —Ñ–æ–Ω–∞: ${fileError}`);
                }
            }

            logger.info(`–£–¥–∞–ª–µ–Ω –∫–æ–Ω—Ñ–∏–≥ ${key} ${value}`);

            const embed = createSuccessEmbed(`–ö–æ–Ω—Ñ–∏–≥ **${key}** **${value}** —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω`, interaction.user);
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞:", error);

            const embed = createErrorEmbed("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞", interaction.user);
            await interaction.reply({ embeds: [embed] });
        }
    }

    @Slash({ description: "–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞" })
    @Guard(RequireRoles(["high_mod_level", "medium_mod_level"]))
    async get(
        interaction: CommandInteraction
    ) {
        try {
            const configRepository = AppDataSource.getRepository(Config);
            const allConfigs = await configRepository.find();
            if (!allConfigs.length) {
                const embed = createErrorEmbed("–ö–æ–Ω—Ñ–∏–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", interaction.user);
                return interaction.reply({ embeds: [embed] });
            }

            const configsByKey = ConfigCommands.groupConfigsByKey(allConfigs);
            const embed = createEmbed({
                title: "‚öôÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–µ—Ä–∞",
                description: "–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞",
                color: EmbedColors.INFO,
                timestamp: true,
                footer: {
                    text: `–ó–∞–ø—Ä–æ—Å–∏–ª ${interaction.user.username}`,
                    iconURL: interaction.user.displayAvatarURL()
                },
                fields: ConfigCommands.createConfigFields(configsByKey)
            });

            await interaction.reply({ embeds: [embed], ephemeral: true });
            return;
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞:", error);

            const embed = createErrorEmbed("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞", interaction.user);
            await interaction.reply({ embeds: [embed] });
        }
    }

    private static groupConfigsByKey(configs: Config[]): Record<string, string[]> {
        const grouped: Record<string, string[]> = {};

        for (const config of configs) {
            if (!grouped[config.key]) {
                grouped[config.key] = [];
            }
            grouped[config.key].push(config.value);
        }

        return grouped;
    }

    private static createConfigFields(configsByKey: Record<string, string[]>): Array<{ name: string, value: string }> {
        const fields: Array<{ name: string, value: string }> = [];

        for (const [key, values] of Object.entries(configsByKey)) {
            let displayName = key;

            switch (key) {
                case "low_mod_level":
                    displayName = "üü¢ Low Mod Roles";
                    break;
                case "medium_mod_level":
                    displayName = "üü† Medium Mod Roles";
                    break;
                case "high_mod_level":
                    displayName = "üî¥ High Mod Roles";
                    break;
                case "ignore_voice_channel_exp":
                    displayName = "üîá Ignored Voice Channels";
                    break;
                case "user_commands_channel":
                    displayName = "üí¨ User Commands Channels";
                    break;
                case "custom_background":
                    displayName = "üñºÔ∏è Custom Profile Backgrounds";
                    break;
                case "gallery_chat":
                    displayName = "üñºÔ∏è Gallery chat";
                    break;
                case "log_chat":
                    displayName = "üí¨ Log chat";
                    break;
                case "give_role_chat":
                    displayName = "üí¨ Chat for giving roles";
                    break;
                case "give_role_id":
                    displayName = "üí¨ IDs for giving roles";
                    break;
                case "role_description":
                    displayName = "üìù Role Descriptions";
                    break;
            }

            if (key === "role_description") {
                fields.push({
                    name: displayName,
                    value: values.map(v => {
                        const [roleId, ...descParts] = v.split(":");
                        const desc = descParts.join(":");
                        return `\`${roleId}\`: ${desc}`;
                    }).join("\n")
                });
            } else {
                fields.push({
                    name: displayName,
                    value: values.map(v => `\`${v}\``).join(", ")
                });
            }
        }

        return fields;
    }
}

# ./src/commands/giftCommands.ts
import { Discord, Slash, SlashOption, Guard, SlashGroup } from "discordx";
import { CommandInteraction, ApplicationCommandOptionType } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User as DBUser } from "../entities/User.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { createErrorEmbed, createGiftListEmbed, createGiftResultEmbed, createSuccessEmbed } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { Currency } from "../entities/Currency.js";
import { GiftReward } from "../types/giftTypes.js";
import { openGift, pluralizeGifts } from "../utils/giftUtils.js";
import { GiftStats } from "../entities/GiftStats.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";
import { RequireRoles } from "../utils/decorators/RequireRoles.js";

const VOICE_MINUTES_PER_GIFT = 480;

@Discord()
class MyGiftsCommand {
    @Slash({
        name: "mygifts",
        description: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∞—à–∏—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–¥–∞—Ä–∫–∞—Ö"
    })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async mygifts(
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();
            const discordUser = interaction.user;

            const userRepository = AppDataSource.getRepository(DBUser);
            const dbUser = await userRepository.findOneOrFail({
                where: { discordId: discordUser.id }
            });

            const giftStatsRepository = AppDataSource.getRepository(GiftStats);
            const giftStats = await giftStatsRepository.findOneOrFail({
                where: { discordId: discordUser.id }
            });

            const totalVoiceMinutes = Number(dbUser.voiceMinutes);

            const potentialGifts = Math.floor(totalVoiceMinutes / VOICE_MINUTES_PER_GIFT);

            const claimedGifts = giftStats.claimedGiftsFromVoice;
            const availableGifts = giftStats.availableGifts;

            const minutesForNextGift = VOICE_MINUTES_PER_GIFT - (totalVoiceMinutes % VOICE_MINUTES_PER_GIFT);
            const hoursForNextGift = Math.floor(minutesForNextGift / 60);
            const remainingMinutes = minutesForNextGift % 60;

            const embed = createGiftListEmbed(
                interaction.user,
                totalVoiceMinutes,
                availableGifts,
                claimedGifts,
                hoursForNextGift,
                remainingMinutes,
                giftStats
            );

            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ mygifts:", error);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–¥–∞—Ä–∫–æ–≤", interaction.user);
            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }
}

@Discord()
class OpenGiftCommand {
    @Slash({
        name: "opengift",
        description: "–û—Ç–∫—Ä—ã—Ç—å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–π –ø–æ–¥–∞—Ä–æ–∫"
    })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async opengift(
        @SlashOption({
            name: "amount",
            description: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–∞—Ä–∫–æ–≤ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1)",
            type: ApplicationCommandOptionType.Integer,
            required: false,
            minValue: 1,
            maxValue: 10
        })
        amount: number = 1,
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();
            const discordUser = interaction.user;

            const userRepository = AppDataSource.getRepository(DBUser);
            const dbUser = await userRepository.findOneOrFail({
                where: { discordId: discordUser.id },
                relations: ["currency"]
            });

            const giftStatsRepository = AppDataSource.getRepository(GiftStats);
            const giftStats = await giftStatsRepository.findOneOrFail({
                where: { discordId: discordUser.id }
            });

            if (giftStats.availableGifts <= 0) {
                const errorEmbed = createErrorEmbed(
                    "–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–¥–∞—Ä–∫–æ–≤ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è. –ù–∞–∫–∞–ø–ª–∏–≤–∞–π—Ç–µ –≤—Ä–µ–º—è –≤ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–∞–Ω–∞–ª–∞—Ö, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏!",
                    interaction.user
                );
                return await interaction.editReply({ embeds: [errorEmbed] });
            }

            const giftsToOpen = Math.min(amount, giftStats.availableGifts);

            const results: GiftReward[] = [];
            let totalWin = 0;

            for (let i = 0; i < giftsToOpen; i++) {
                const reward = openGift();
                results.push(reward);

                if (reward.type === 'currency' && reward.amount) {
                    totalWin += reward.amount;
                }
            }

            giftStats.availableGifts -= giftsToOpen;
            giftStats.totalGiftsClaimed += giftsToOpen;
            await giftStatsRepository.save(giftStats);

            if (totalWin > 0) {
                const currencyRepository = AppDataSource.getRepository(Currency);
                await currencyRepository.increment(
                    { id: dbUser.currency.id },
                    "currencyCount",
                    totalWin
                );
            }

            const embed = createGiftResultEmbed(results, totalWin, 0, interaction);

            if (giftsToOpen > 1) {
                embed.setTitle(`üéÅ –û—Ç–∫—Ä—ã—Ç–∏–µ ${giftsToOpen} ${pluralizeGifts(giftsToOpen)} üéÅ`);
                embed.setDescription(`<@${interaction.user.id}> –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç ${giftsToOpen} ${pluralizeGifts(giftsToOpen)}!`);
            }

            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordUser.id} –æ—Ç–∫—Ä—ã–ª ${giftsToOpen} –ø–æ–¥–∞—Ä–∫–æ–≤ –∏ –ø–æ–ª—É—á–∏–ª ${totalWin}$`);

            await interaction.editReply({ embeds: [embed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ opengift:", error);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –ø–æ–¥–∞—Ä–∫–∞", interaction.user);
            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }
}

@Discord()
@SlashGroup({
    description: "–ö–æ–º–∞–Ω–¥—ã –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ø–æ–¥–∞—Ä–∫–∞–º–∏ [–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä]",
    name: "gift",
    defaultMemberPermissions: "0",
    dmPermission: false,
})
@SlashGroup("gift")
class GiftModCommands {
    @Slash({
        name: "add",
        description: "–î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é [–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä]"
    })
    @EnsureUser()
    @Guard(
        EnsureUserGuard(),
        RequireRoles(["high_mod_level", "medium_mod_level"])
    )
    async add(
        @SlashOption({
            name: "user",
            description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏",
            type: ApplicationCommandOptionType.User,
            required: true
        })
        user: any,

        @SlashOption({
            name: "amount",
            description: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–∞—Ä–∫–æ–≤ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è",
            type: ApplicationCommandOptionType.Integer,
            required: true,
            minValue: 1
        })
        amount: number,

        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();

            const targetUserId = user.id;

            const giftStatsRepository = AppDataSource.getRepository(GiftStats);
            const giftStats = await giftStatsRepository.findOneOrFail({
                where: { discordId: targetUserId }
            });

            giftStats.availableGifts += amount;
            await giftStatsRepository.save(giftStats);

            const successEmbed = createSuccessEmbed(
                `–£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ **${amount} ${pluralizeGifts(amount)}** –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${targetUserId}>.\n` +
                `–¢–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–æ: **${giftStats.availableGifts} ${pluralizeGifts(giftStats.availableGifts)}**`,
                interaction.user
            );

            logger.info(`–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä ${interaction.user.id} –¥–æ–±–∞–≤–∏–ª ${amount} –ø–æ–¥–∞—Ä–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${targetUserId}`);

            await interaction.editReply({ embeds: [successEmbed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ addgifts:", error);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–¥–∞—Ä–∫–æ–≤", interaction.user);
            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }

    @Slash({
        name: "remove",
        description: "–£–¥–∞–ª–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è [–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä]"
    })
    @EnsureUser()
    @Guard(
        EnsureUserGuard(),
        RequireRoles(["high_mod_level", "medium_mod_level"])
    )
    async remove(
        @SlashOption({
            name: "user",
            description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, —É –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏",
            type: ApplicationCommandOptionType.User,
            required: true
        })
        user: any,

        @SlashOption({
            name: "amount",
            description: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–∞—Ä–∫–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è",
            type: ApplicationCommandOptionType.Integer,
            required: true,
            minValue: 1
        })
        amount: number,

        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();

            const targetUserId = user.id;

            const giftStatsRepository = AppDataSource.getRepository(GiftStats);
            const giftStats = await giftStatsRepository.findOneOrFail({
                where: { discordId: targetUserId }
            });

            const giftsToRemove = Math.min(amount, giftStats.availableGifts);
            giftStats.availableGifts -= giftsToRemove;
            await giftStatsRepository.save(giftStats);

            const successEmbed = createSuccessEmbed(
                `–£—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ **${giftsToRemove} ${pluralizeGifts(giftsToRemove)}** —É <@${targetUserId}>.\n` +
                `–¢–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–æ: **${giftStats.availableGifts} ${pluralizeGifts(giftStats.availableGifts)}**`,
                interaction.user
            );

            logger.info(`–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä ${interaction.user.id} —É–¥–∞–ª–∏–ª ${giftsToRemove} –ø–æ–¥–∞—Ä–∫–æ–≤ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${targetUserId}`);

            await interaction.editReply({ embeds: [successEmbed] });
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ removegifts:", error);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–¥–∞—Ä–∫–æ–≤", interaction.user);
            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }
}

export { MyGiftsCommand, OpenGiftCommand, GiftModCommands };

# ./src/commands/aboutCommand.ts
import { Discord, Slash, Guard } from "discordx";
import { CommandInteraction, ContainerBuilder, MediaGalleryBuilder, MediaGalleryItemBuilder, MessageFlags, SectionBuilder, SeparatorBuilder, TextDisplayBuilder } from "discord.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import logger from "../services/logger.js";
import { Cooldown } from "../utils/decorators/CoommandCooldown.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";
import { readFileSync } from "fs";
import { join } from "path";

@Discord()
class AboutCommand {
    @Slash({ description: "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ" })
    @EnsureUser()
    @Guard(
        Cooldown({ minutes: 1 }),
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async about(
        interaction: CommandInteraction
    ) {
        try {
            const changeLogFromMd = readFileSync(join(process.cwd(), "change_log.md"), 'utf-8') || "–ò–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ—Ç";
            const content = new TextDisplayBuilder().setContent(
                '### ü§ñ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ\n–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ –±–æ—Ç–∞: <@805350459337998346>, <@329535901938089995>'
            );
            const changeLog = new TextDisplayBuilder().setContent(
                `### üìù –ù–µ–¥–∞–≤–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è\n-# [–†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –±–æ—Ç–∞ –Ω–∞ Github](https://github.com/akorutant/MarmokBot)\n${changeLogFromMd}`
            );
            const footer = new TextDisplayBuilder().setContent('–í —Å–ª—É—á–∞–µ –æ—à–∏–±–æ–∫ –±–æ—Ç–∞ –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –≤ [—Ç–µ–ª–µ–≥—Ä–∞–º](https://t.me/sufferedkid)')
            const separator = new SeparatorBuilder()
            const component = new ContainerBuilder().setAccentColor(0x903FFF)
                .addTextDisplayComponents(content)
                .addSeparatorComponents(separator)
                .addTextDisplayComponents(changeLog)
                .addSeparatorComponents(separator)
                .addTextDisplayComponents(footer)
            await interaction.reply({
                flags: MessageFlags.IsComponentsV2,
                components: [component]
            })
        }
        catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ about", error)
        }
    }
}

export default AboutCommand;

# ./src/commands/dailyCommand.ts
import { Discord, Slash, Guard } from "discordx";
import { CommandInteraction } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User as DBUser } from "../entities/User.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { createErrorEmbed } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { Currency } from "../entities/Currency.js";
import { Cooldown } from "../utils/decorators/CoommandCooldown.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";

const currentDate = Math.floor(new Date().getTime() / 1000);

@Discord()
class DailyCommand {
    @Slash({ description: "–ü–æ–ª—É—á–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É" })
    @EnsureUser()
    @Guard(
        Cooldown({days: 1}),
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async daily(
        interaction: CommandInteraction
    ) {
        try {
            await interaction.deferReply();
            const discordUser = interaction.user;
            const currencyRepository = AppDataSource.getRepository(Currency);
            const dbUser = await AppDataSource.getRepository(DBUser).findOneOrFail({
                where: { discordId: discordUser.id },
                relations: ["currency"]
            });

            await currencyRepository.increment(
                { id: dbUser.currency.id }, 
                "currencyCount", 
                100
            );

            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${discordUser.id} –ø–æ–ª—É—á–∏–ª –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É`);
            
            await interaction.editReply("–í—ã –ø–æ–ª—É—á–∏–ª–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É –≤ —Ä–∞–∑–º–µ—Ä–µ 100$");
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ daily:", error);
            const errorEmbed = createErrorEmbed("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–¥–∞—á–µ –Ω–∞–≥—Ä–∞–¥—ã", interaction.user);
            await interaction.editReply({ embeds: [errorEmbed] });
        }
    }
}

export default DailyCommand;

# ./src/commands/currencyCommands.ts
import { 
    Discord, 
    Slash, 
    SlashOption, 
    Guard, 
    SlashGroup
} from "discordx";
import { 
    CommandInteraction, 
    ApplicationCommandOptionType, 
    User as DiscordUser,
    TextChannel as DiscordTextChannel
} from "discord.js";
import { AppDataSource } from "../services/database.js";
import { User } from "../entities/User.js";
import { Currency } from "../entities/Currency.js";
import { Config } from "../entities/Config.js";
import { 
    createCurrencyBalanceEmbed,
    createErrorEmbed, 
    createSuccessEmbed, 
    createTransferNotificationEmbed 
} from "../utils/embedBuilder.js";
import logger from "../services/logger.js";
import { ChannelGuard } from "../utils/decorators/ChannelGuard.js";
import { EnsureUserGuard } from "../utils/decorators/EnsureUserGuard.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { RequireRoles } from "../utils/decorators/RequireRoles.js";

@Discord()
class TransferCommand {
    @Slash({
        description: "–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤–∞–ª—é—Ç—É –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é",
        name: "transfer"
    })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard()
    )
    async transfer(
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤–∞–ª—é—Ç—É",
            name: "user",
            required: true,
            type: ApplicationCommandOptionType.User
        })
        targetDiscordUser: DiscordUser,
        @SlashOption({
            description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ –≤–∞–ª—é—Ç—ã –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞",
            name: "amount",
            required: true,
            type: ApplicationCommandOptionType.Number
        })
        currencyAmount: number,
        interaction: CommandInteraction,
    ) {
        try {
            if (currencyAmount <= 0) {
                const embed = createErrorEmbed("–°—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π!", interaction.user);
                await interaction.reply({ embeds: [embed] });
                return;
            }

            if (targetDiscordUser.id === interaction.user.id) {
                const embed = createErrorEmbed("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤–∞–ª—é—Ç—É —Å–∞–º–æ–º—É —Å–µ–±–µ!", interaction.user);
                await interaction.reply({ embeds: [embed] });
                return;
            }

            const userRepository = AppDataSource.getRepository(User);
            const currencyRepository = AppDataSource.getRepository(Currency);
            const configRepository = AppDataSource.getRepository(Config);

            const sourceUser = await userRepository.findOneOrFail({
                where: { discordId: interaction.user.id },
                relations: ["currency"]
            });

            const commission = Math.ceil(currencyAmount * 0.07);
            const totalAmount = currencyAmount + commission;
            
            if (sourceUser.currency.currencyCount < BigInt(totalAmount)) {
                const embed = createErrorEmbed(
                    `–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–∞–ª—é—Ç—ã –¥–ª—è —ç—Ç–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞! ` +
                    `–ù–µ–æ–±—Ö–æ–¥–∏–º–æ: ${currencyAmount} + ${commission} (–∫–æ–º–∏—Å—Å–∏—è 7%) = ${totalAmount}`,
                    interaction.user
                );
                await interaction.reply({ embeds: [embed] });
                return;
            }

            const targetUser = await userRepository.findOneOrFail({
                where: { discordId: targetDiscordUser.id },
                relations: ["currency"]
            });

            await AppDataSource.transaction(async (manager) => {
                await manager.decrement(
                    Currency,
                    { id: sourceUser.currency.id },
                    "currencyCount",
                    totalAmount
                );

                await manager.increment(
                    Currency,
                    { id: targetUser.currency.id },
                    "currencyCount",
                    currencyAmount
                );
            });

            const senderEmbed = createSuccessEmbed(
                `–í—ã —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–≤–µ–ª–∏ ${currencyAmount} –≤–∞–ª—é—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${targetDiscordUser.id}>!
` +
                `–ö–æ–º–∏—Å—Å–∏—è —Å–æ—Å—Ç–∞–≤–∏–ª–∞ ${commission} (7%).
` +
                `–û–±—â–∞—è —Å—É–º–º–∞ —Å–ø–∏—Å–∞–Ω–∏—è: ${totalAmount}`,
                interaction.user
            );
            
            await interaction.reply({ embeds: [senderEmbed] });
            
            const receiverEmbed = createTransferNotificationEmbed(
                interaction.user,
                targetDiscordUser,
                currencyAmount
            );
            
            try {
                const dm = await targetDiscordUser.createDM();
                await dm.send({ embeds: [receiverEmbed] });
                logger.info(`–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø–µ—Ä–µ–≤–æ–¥–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –õ–° ${targetDiscordUser.id}`);
            } catch {
                logger.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –õ–° –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${targetDiscordUser.id}`);
                const commandsConfig = await configRepository.findOne({ where: { key: "user_commands_channel" } });
                if (commandsConfig?.value) {
                    const ch = interaction.client.channels.cache.get(commandsConfig.value) as DiscordTextChannel;
                    if (ch) await ch.send({ content: `<@${targetDiscordUser.id}>`, embeds: [receiverEmbed] });
                }
            }

            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${interaction.user.id} –ø–µ—Ä–µ–≤–µ–ª ${currencyAmount} –≤–∞–ª—é—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${targetDiscordUser.id}`);
        } catch (error) {
            const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
            await interaction.reply({ embeds: [embed] });
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–≤–æ–¥–µ –≤–∞–ª—é—Ç—ã:", error);
        }
    }
}


@Discord()
class BalanceCommand {
    @Slash({ description: "–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è" })
    @EnsureUser()
    @Guard(
        ChannelGuard("user_commands_channel"),
        EnsureUserGuard(),
    )
    async balance(
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            name: "user",
            required: false,
            type: ApplicationCommandOptionType.User
        })
        discordUser: DiscordUser | undefined,
        interaction: CommandInteraction,
    ) {
        try {
            const targetUser = discordUser || interaction.user;
            const userRepository = AppDataSource.getRepository(User);

            const user = await userRepository.findOneOrFail({
                where: { discordId: targetUser.id },
                relations: ["currency"]
            });

            const embed = createCurrencyBalanceEmbed(targetUser, user.currency.currencyCount, interaction.user);
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
            await interaction.reply({ embeds: [embed] });
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –±–∞–ª–∞–Ω—Å–∞: %O", error);
        }
    }
}

@Discord()
@SlashGroup({ 
    description: "–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", 
    name: "currency",
    defaultMemberPermissions: "0", 
    dmPermission: false, 
})
@SlashGroup("currency")
class CurrencyCommands {
    @Slash({ description: "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∫–æ–ª-–≤–æ –≤–∞–ª—é—Ç—ã" })
    @EnsureUser()
    @Guard(
        EnsureUserGuard(),
        RequireRoles(["high_mod_level", "medium_mod_level"])
    )
    async set(
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            name: "user",
            required: true,
            type: ApplicationCommandOptionType.User
        })
        discordUser: DiscordUser,
        @SlashOption({
            description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ –≤–∞–ª—é—Ç—ã –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é",
            name: "amount",
            required: true,
            type: ApplicationCommandOptionType.Number
        })
        currencyAmount: number,
        interaction: CommandInteraction,
    ) {
        try {
            const userRepository = AppDataSource.getRepository(User);
            const currencyRepository = AppDataSource.getRepository(Currency);

            const user = await userRepository.findOneOrFail({
                where: { discordId: discordUser.id },
                relations: ["currency"]
            });

            user.currency.currencyCount = BigInt(currencyAmount);
            await currencyRepository.save(user.currency);
            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${discordUser.id} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ ${currencyAmount} –≤–∞–ª—é—Ç—ã`);

            const embed = createSuccessEmbed(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${discordUser.id}> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –≤–∞–ª—é—Ç—ã = ${currencyAmount}`, interaction.user);
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
            await interaction.reply({ embeds: [embed] });
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –≤–∞–ª—é—Ç—ã: %O", error);
        }
    }

    @Slash({ description: "–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∫–æ–ª-–≤–æ –≤–∞–ª—é—Ç—ã" })
    @EnsureUser()
    @Guard(
        EnsureUserGuard(),
        RequireRoles(["high_mod_level", "medium_mod_level"])
    )
    async add(
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            name: "user",
            required: true,
            type: ApplicationCommandOptionType.User
        })
        discordUser: DiscordUser,
        @SlashOption({
            description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ –≤–∞–ª—é—Ç—ã –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è",
            name: "amount",
            required: true,
            type: ApplicationCommandOptionType.Number
        })
        currencyAmount: number,
        interaction: CommandInteraction,
    ) {
        try {
            const userRepository = AppDataSource.getRepository(User);
            const currencyRepository = AppDataSource.getRepository(Currency);

            const user = await userRepository.findOneOrFail({
                where: { discordId: discordUser.id },
                relations: ["currency"]
            });

            await currencyRepository.increment({ id: user.currency.id }, "currencyCount", currencyAmount);
            logger.info(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${discordUser.id} –¥–æ–±–∞–≤–ª–µ–Ω–æ ${currencyAmount} –≤–∞–ª—é—Ç—ã`);

            const embed = createSuccessEmbed(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <@${discordUser.id}> –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤–∞–ª—é—Ç—ã: +${currencyAmount}`, interaction.user);
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
            await interaction.reply({ embeds: [embed] });
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤–∞–ª—é—Ç—ã: %O", error);
        }
    }

    @Slash({ description: "–°–Ω—è—Ç—å –≤–∞–ª—é—Ç—É —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è" })
    @EnsureUser()
    @Guard(
        EnsureUserGuard(),
        RequireRoles(["high_mod_level", "medium_mod_level"])
    )
    async remove(
        @SlashOption({
            description: "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            name: "user",
            required: true,
            type: ApplicationCommandOptionType.User
        })
        discordUser: DiscordUser,
        @SlashOption({
            description: "–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–ª-–≤–æ –≤–∞–ª—é—Ç—ã –¥–ª—è –≤—ã—á–∏—Ç–∞–Ω–∏—è",
            name: "amount",
            required: true,
            type: ApplicationCommandOptionType.Number
        })
        currencyAmount: number,
        interaction: CommandInteraction,
    ) {
        try {
            const userRepository = AppDataSource.getRepository(User);
            const currencyRepository = AppDataSource.getRepository(Currency);

            const user = await userRepository.findOneOrFail({
                where: { discordId: discordUser.id },
                relations: ["currency"]
            });

            await currencyRepository.increment({ id: user.currency.id }, "currencyCount", -currencyAmount);
            logger.info(`–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${discordUser.id} –≤—ã—á—Ç–µ–Ω–æ ${currencyAmount} –≤–∞–ª—é—Ç—ã`);

            const embed = createSuccessEmbed(`–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <@${discordUser.id}> –≤—ã—á—Ç–µ–Ω–æ –≤–∞–ª—é—Ç—ã: -${currencyAmount}`, interaction.user);
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            const embed = createErrorEmbed("–û—à–∏–±–∫–∞! –ó–∞ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º.", interaction.user);
            await interaction.reply({ embeds: [embed] });
            logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –≤–∞–ª—é—Ç—ã: %O", error);
        }
    }
}

export default { CurrencyCommands, BalanceCommand, TransferCommand};

# ./src/events/RewardsListener.ts
import { Discord, On, ArgsOf, Client } from "discordx";
import { AppDataSource } from "../services/database.js";
import { User } from "../entities/User.js";
import { Exp } from "../entities/Exp.js";
import { Currency } from "../entities/Currency.js";
import { GiftStats } from "../entities/GiftStats.js";
import { TextChannel, EmbedBuilder } from "discord.js";
import logger from "../services/logger.js";
import { BlockVoicePresentInChannels } from "../utils/decorators/BlockVoicePresentInChannels.js";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import { CheckLevelUp, setDiscordClient as setLevelUpClient } from "../utils/decorators/CheckLevelUp.js";
import { RARITY_COLORS } from "../constants/colors.js";
import { CheckGiftProgress, setDiscordClient as setGiftClient, checkAndProcessGifts, sendGiftNotification } from "../utils/decorators/CheckGiftProgress.js";

const activeVoiceIntervals = new Map<string, NodeJS.Timeout>();
let discordClient: Client;

@Discord()
export default class RewardsListener {
  constructor(private client: Client) {
    setLevelUpClient(client);
    setGiftClient(client);
    discordClient = client;
    logger.info("RewardsListener initialized");
  }

  @On({ event: "messageCreate" })
  @EnsureUser()
  @CheckLevelUp()
  @CheckGiftProgress()
  async onMessage([message]: ArgsOf<"messageCreate">) {
    if (message.author.bot) return;
    const userRepository = AppDataSource.getRepository(User);
    const expRepository = AppDataSource.getRepository(Exp);
    const currencyRepository = AppDataSource.getRepository(Currency);

    await userRepository.increment({ discordId: message.author.id }, "messageCount", 1);
    await expRepository.increment({ id: (await userRepository.findOneOrFail({ where: { discordId: message.author.id }, relations: ["exp"] })).exp.id }, "exp", 1);
    await currencyRepository.increment({ id: (await userRepository.findOneOrFail({ where: { discordId: message.author.id }, relations: ["currency"] })).currency.id }, "currencyCount", 1);

    logger.info(`Message processed for ${message.author.id}`);
  }

  @On({ event: "voiceStateUpdate" })
  @BlockVoicePresentInChannels()
  @EnsureUser()
  @CheckLevelUp()
  @CheckGiftProgress()
  async onVoiceStateUpdate([oldState, newState]: ArgsOf<"voiceStateUpdate">) {
    const userId = newState.id;

    const joined = !oldState.channel && newState.channel;
    const left = oldState.channel && !newState.channel;

    const userRepo = AppDataSource.getRepository(User);
    const expRepo = AppDataSource.getRepository(Exp);
    const currencyRepo = AppDataSource.getRepository(Currency);

    if (joined) {
      const interval = setInterval(async () => {
        try {
          const user = await userRepo.findOneOrFail({
            where: { discordId: userId },
            relations: ["exp", "currency"],
          });

          await userRepo.increment({ discordId: userId }, "voiceMinutes", 1);
          await expRepo.increment({ id: user.exp.id }, "exp", 2);
          await currencyRepo.increment({ id: user.currency.id }, "currencyCount", 1);

          const giftResult = await checkAndProcessGifts(userId);

          if (giftResult && giftResult.newGifts > 0) {
            await sendGiftNotification(userId, giftResult.newGifts, giftResult.totalAvailable);
          }

          logger.info(`+1 –º–∏–Ω—É—Ç–∞ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ: ${userId}, –∫–∞–Ω–∞–ª: ${oldState.channelId}`);
        } catch (err) {
          logger.error(`Voice interval error for ${userId}: ${err}`);
        }
      }, 60 * 1000);

      activeVoiceIntervals.set(userId, interval);
      logger.info(`Voice timer started for ${userId}`);
    }

    if (left) {
      const interval = activeVoiceIntervals.get(userId);
      if (interval) {
        clearInterval(interval);
        activeVoiceIntervals.delete(userId);
        logger.info(`Voice timer cleared for ${userId}`);
      }

      try {
        const giftResult = await checkAndProcessGifts(userId, true);

        if (giftResult && giftResult.newGifts > 0) {
          await sendGiftNotification(userId, giftResult.newGifts, giftResult.totalAvailable);
          logger.info(`Gifts finalized after voice exit: ${userId} +${giftResult.newGifts}`);
        } else {
          logger.debug(`No new gifts after voice exit for ${userId}`);
        }
      } catch (err) {
        logger.error(`Error finalizing voice exit for ${userId}: ${err}`);
      }
    }
  }
}

# ./src/events/RoleSelectorListener.ts
import { Discord, Once, SelectMenuComponent } from "discordx";
import { 
    Client, 
    ActionRowBuilder, 
    StringSelectMenuBuilder, 
    StringSelectMenuOptionBuilder,
    StringSelectMenuInteraction,
    TextChannel,
    GuildMember
} from "discord.js";
import { AppDataSource } from "../services/database.js";
import { Config } from "../entities/Config.js";
import { createEmbed, EmbedColors } from "../utils/embedBuilder.js";
import logger from "../services/logger.js";

@Discord()
export class RoleSelector {
    @Once({ event: "ready" })
    async onReady([client]: [Client]): Promise<void> {
        try {
            const configRepository = AppDataSource.getRepository(Config);
            const roleChannels = await configRepository.find({ where: { key: "give_role_chat" } });
            
            if (roleChannels.length) {
                logger.info(`–ù–∞–π–¥–µ–Ω–æ ${roleChannels.length} –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –≤—ã–¥–∞—á–∏ —Ä–æ–ª–µ–π`);
            }
            
            logger.info("‚úÖ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º–µ–Ω—é —Ä–æ–ª–µ–π –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é");
        } catch (error) {
            logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ–Ω—é —Ä–æ–ª–µ–π: ${error}`);
        }
    }
    
    static async createRoleMenu(channelId: string, client: Client): Promise<void> {
        try {
            const configRepository = AppDataSource.getRepository(Config);
            
            const roleConfigs = await configRepository.find({ where: { key: "give_role_id" } });
            
            if (!roleConfigs.length) {
                logger.error("–ù–µ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ä–æ–ª–µ–π –¥–ª—è –≤—ã–¥–∞—á–∏");
                return;
            }
            
            const channel = client.channels.cache.get(channelId) as TextChannel;
            if (!channel || !channel.isTextBased()) {
                logger.error(`–ö–∞–Ω–∞–ª ${channelId} –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–µ–∫—Å—Ç–æ–≤—ã–º`);
                return;
            }
            
            const roleDescriptions = await configRepository.find({ where: { key: "role_description" } });
            
            const descriptionMap: Record<string, string> = {};
            for (const desc of roleDescriptions) {
                const [id, ...descParts] = desc.value.split(":");
                if (id) {
                    descriptionMap[id] = descParts.join(":");
                }
            }
            
            const availableRoles = [];
            for (const roleConfig of roleConfigs) {
                const guild = channel.guild;
                const role = guild.roles.cache.get(roleConfig.value);
                if (role) {
                    availableRoles.push(role);
                }
            }
            
            if (!availableRoles.length) {
                logger.error("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–æ–ª–µ–π –¥–ª—è –≤—ã–¥–∞—á–∏");
                return;
            }
            
            logger.info("–î–æ–ø—É—Å—Ç–∏–º—ã–µ —Ä–æ–ª–∏: " + JSON.stringify(availableRoles.map(role => role.id)));
            
            const options = availableRoles.map(role => {
                const option = new StringSelectMenuOptionBuilder()
                    .setLabel(role.name)
                    .setValue(role.id);
                
                const description = `–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å/—É–±—Ä–∞—Ç—å —Ä–æ–ª—å ${role.name}`;
                option.setDescription(description.substring(0, 100)); 
                
                return option;
            });
            
            const select = new StringSelectMenuBuilder()
                .setCustomId('select-role')
                .setPlaceholder('–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å')
                .addOptions(options);
                
            const row = new ActionRowBuilder<StringSelectMenuBuilder>()
                .addComponents(select);
            
            const embed = createEmbed({
                title: "üé≠ –í—ã–±–æ—Ä —Ä–æ–ª–µ–π",
                description: "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –µ—ë. –ï—Å–ª–∏ —É –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–∞—è —Ä–æ–ª—å, –æ–Ω–∞ –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–∞.",
                color: 0xED4245,
                fields: [
                    {
                        name: "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–æ–ª–∏",
                        value: availableRoles.map(role => {
                            const desc = descriptionMap[role.id] ? 
                                ` - ${descriptionMap[role.id]}` : '';
                            return `‚Ä¢ **${role.name}**${desc}`;
                        }).join('\n\n')
                    }
                ]
            });
            
            await channel.send({
                embeds: [embed],
                components: [row]
            });
            
            logger.info(`–°–æ–∑–¥–∞–Ω–æ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–µ–π –≤ –∫–∞–Ω–∞–ª–µ ${channel.name}`);
            
        } catch (error) {
            logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ–Ω—é —Ä–æ–ª–µ–π: ${error}`);
        }
    }
    
    @SelectMenuComponent({ id: "select-role" })
    async handleRoleSelection(interaction: StringSelectMenuInteraction): Promise<void> {
        await interaction.deferReply({ ephemeral: true }).catch(error => {
            logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–º –æ—Ç–≤–µ—Ç–µ: ${error}`);
            return;
        });
        
        try {
            const selectedRoleId = interaction.values[0];
            const selectedRole = interaction.guild?.roles.cache.get(selectedRoleId);
            
            if (!selectedRole) {
                await interaction.editReply({
                    content: '‚ùå –û—à–∏–±–∫–∞: –≤—ã–±—Ä–∞–Ω–Ω–∞—è —Ä–æ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.'
                }).catch(error => {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ–± –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ä–æ–ª–∏: ${error}`);
                });
                return;
            }
            
            if (!interaction.member || !(interaction.member instanceof GuildMember)) {
                await interaction.editReply({
                    content: '‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ.'
                }).catch(error => {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ: ${error}`);
                });
                return;
            }
            
            const member = interaction.member as GuildMember;
            
            logger.info("–†–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: " + JSON.stringify(Array.from(member.roles.cache.keys())));
            
            if (member.roles.cache.has(selectedRoleId)) {
                try {
                    await member.roles.remove(selectedRoleId);
                    await interaction.editReply({
                        content: `‚úÖ –†–æ–ª—å ${selectedRole.name} –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞.`
                    }).catch(error => {
                        logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ–± —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏: ${error}`);
                    });
                    logger.info(`–†–æ–ª—å ${selectedRole.name} —É–¥–∞–ª–µ–Ω–∞ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${interaction.user.username}`);
                } catch (roleError) {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏: ${roleError}`);
                    await interaction.editReply({
                        content: '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏. –í–æ–∑–º–æ–∂–Ω–æ, –±–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø—Ä–∞–≤.'
                    }).catch(error => {
                        logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ–± –æ—à–∏–±–∫–µ —É–¥–∞–ª–µ–Ω–∏—è —Ä–æ–ª–∏: ${error}`);
                    });
                }
            } else {
                try {
                    await member.roles.add(selectedRoleId);
                    await interaction.editReply({
                        content: `‚úÖ –í—ã –ø–æ–ª—É—á–∏–ª–∏ —Ä–æ–ª—å ${selectedRole.name}!`
                    }).catch(error => {
                        logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏: ${error}`);
                    });
                    logger.info(`–†–æ–ª—å ${selectedRole.name} –≤—ã–¥–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${interaction.user.username}`);
                } catch (roleError) {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏: ${roleError}`);
                    await interaction.editReply({
                        content: '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏. –í–æ–∑–º–æ–∂–Ω–æ, –±–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø—Ä–∞–≤.'
                    }).catch(error => {
                        logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ–± –æ—à–∏–±–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–æ–ª–∏: ${error}`);
                    });
                }
            }
        } catch (error) {
            logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–¥–∞—á–µ —Ä–æ–ª–∏: ${error}`);
            try {
                await interaction.editReply({
                    content: '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–æ–ª–µ–π.'
                });
            } catch (replyError) {
                logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–æ–ª–µ–π: ${replyError}`);
            }
        }
    }
}

# ./src/events/ReactionsListener.ts
import { Discord, On, ArgsOf } from "discordx";
import { Client, Message, TextChannel } from "discord.js";
import { AppDataSource } from "../services/database.js";
import { Config } from "../entities/Config.js";
import logger from "../services/logger.js";

@Discord()
export class ReactionsListener {
    @On({ event: "messageCreate" })
    async onMessageCreate([message]: ArgsOf<"messageCreate">) {
        try {
            if (message.author.bot) return;

            const configRepository = AppDataSource.getRepository(Config);
            const galleryConfig = await configRepository.findOne({
                where: { key: "gallery_chat" }
            });

            if (!galleryConfig || !galleryConfig.value) {
                logger.warn("–ö–æ–Ω—Ñ–∏–≥ gallery_chat –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }

            if (message.channelId !== galleryConfig.value) return;

            const hasImage = message.attachments.some(attachment =>
                attachment.contentType?.startsWith("image/") ||
                attachment.contentType?.startsWith("video/")
            );

            if (hasImage) {
                await Promise.all(
                    ["üëç", "üëé"].map(emoji => message.react(emoji))
                );
                logger.info(`–î–æ–±–∞–≤–ª–µ–Ω—ã —Ä–µ–∞–∫—Ü–∏–∏ –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é –æ—Ç ${message.author.tag}`);
            }
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ ReactionsListener:", error);
        }
    }
}

# ./src/events/GuildEnterListener.ts
import { Discord, On, ArgsOf } from "discordx";
import { EnsureUser } from "../utils/decorators/EnsureUsers.js";
import logger from "../services/logger.js";

@Discord()
class GuildEnterListener {
  @On({ event: "guildMemberAdd" })
  @EnsureUser()
  async onGuildMemberAdd([member]: ArgsOf<"guildMemberAdd">) {
    logger.info("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω/–æ–±–Ω–æ–≤–ª–µ–Ω –≤ –ë–î: %s", member.id);
  }
}

export default GuildEnterListener;

# ./src/events/LogsListener.ts
import { Discord, On, ArgsOf } from "discordx";
import {
    Message,
    MessageType,
    PartialMessage,
    TextChannel as DiscordTextChannel,
} from "discord.js";
import { AppDataSource } from "../services/database.js";
import { Config } from "../entities/Config.js";
import logger from "../services/logger.js";
import {
    createDeletedMessageLogEmbed,
    createEditedMessageLogEmbed,
    createContentPartEmbed
} from "../utils/embedBuilder.js";

const MESSAGE_CHAR_LIMIT = 2000;

@Discord()
export class LogsListener {
    @On({ event: "messageDelete" })
    async onMessageDelete([rawMessage]: ArgsOf<"messageDelete">) {
        try {
            let message = rawMessage as Message | PartialMessage;
            if (message.partial) {
                message = await message.fetch();
            }

            if (message.author?.bot) return;

            const configRepository = AppDataSource.getRepository(Config);
            const logConfig = await configRepository.findOne({ where: { key: "log_chat" } });
            if (!logConfig?.value) {
                logger.warn("–ö–æ–Ω—Ñ–∏–≥ log_chat –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }

            const logChannel = message.client.channels.cache.get(logConfig.value) as DiscordTextChannel;
            if (!logChannel) {
                logger.warn(`–ö–∞–Ω–∞–ª –ª–æ–≥–æ–≤ —Å ID ${logConfig.value} –Ω–µ –Ω–∞–π–¥–µ–Ω`);
                return;
            }

            const embed = createDeletedMessageLogEmbed(message);

            if (message.content) {
                const contentChunks = LogsListener.splitMessage(message.content);

                if (contentChunks.length === 1) {
                    embed.addFields({ name: "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ", value: contentChunks[0] });
                    await logChannel.send({ embeds: [embed] });
                } else {
                    embed.addFields({ name: "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ (—á–∞—Å—Ç—å 1)", value: contentChunks[0] });
                    await logChannel.send({ embeds: [embed] });

                    for (let i = 1; i < contentChunks.length; i++) {
                        const followUpEmbed = createContentPartEmbed(
                            `–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è (—á–∞—Å—Ç—å ${i + 1})`,
                            contentChunks[i],
                            "#FF0000"
                        );
                        await logChannel.send({ embeds: [followUpEmbed] });
                    }
                }
            } else {
                await logChannel.send({ embeds: [embed] });
            }

            logger.info(`–ó–∞–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–æ —É–¥–∞–ª–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${message.author?.tag} –≤ –∫–∞–Ω–∞–ª–µ ${message.channelId}`);
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ LogsListener (onMessageDelete):", error);
        }
    }

    @On({ event: "messageUpdate" })
    async onMessageUpdate([rawOld, rawNew]: ArgsOf<"messageUpdate">) {
        try {
            let oldMessage = rawOld as Message | PartialMessage;
            let newMessage = rawNew as Message | PartialMessage;

            if (oldMessage.partial) {
                oldMessage = await oldMessage.fetch();
            }
            if (newMessage.partial) {
                newMessage = await newMessage.fetch();
            }

            if (newMessage.author?.bot || newMessage.type === MessageType.ChannelPinnedMessage) return;
            if (oldMessage.content === newMessage.content) return;

            const configRepository = AppDataSource.getRepository(Config);
            const logConfig = await configRepository.findOne({ where: { key: "log_chat" } });
            if (!logConfig?.value) {
                logger.warn("–ö–æ–Ω—Ñ–∏–≥ log_chat –Ω–µ –Ω–∞–π–¥–µ–Ω");
                return;
            }

            const logChannel = newMessage.client.channels.cache.get(logConfig.value) as DiscordTextChannel;
            if (!logChannel) {
                logger.warn(`–ö–∞–Ω–∞–ª –ª–æ–≥–æ–≤ —Å ID ${logConfig.value} –Ω–µ –Ω–∞–π–¥–µ–Ω`);
                return;
            }

            const embed = createEditedMessageLogEmbed(oldMessage, newMessage, "–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ");

            if (oldMessage.content) {
                const oldChunks = LogsListener.splitMessage(oldMessage.content);

                if (oldChunks.length === 1) {
                    embed.addFields({ name: "–°—Ç–∞—Ä–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ", value: oldChunks[0] });
                } else {
                    embed.addFields({ name: "–°—Ç–∞—Ä–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (—á–∞—Å—Ç—å 1)", value: oldChunks[0] });
                    await logChannel.send({ embeds: [embed] });

                    for (let i = 1; i < oldChunks.length; i++) {
                        const partEmbed = createContentPartEmbed(
                            `–°—Ç–∞—Ä–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (—á–∞—Å—Ç—å ${i + 1})`,
                            oldChunks[i]
                        );
                        await logChannel.send({ embeds: [partEmbed] });
                    }

                    if (newMessage.content) {
                        const newChunks = LogsListener.splitMessage(newMessage.content);
                        for (let i = 0; i < newChunks.length; i++) {
                            const newPartEmbed = createContentPartEmbed(
                                `–ù–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (—á–∞—Å—Ç—å ${i + 1})`,
                                newChunks[i]
                            );
                            await logChannel.send({ embeds: [newPartEmbed] });
                        }
                    }

                    logger.info(`–ó–∞–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–æ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${newMessage.author?.tag} –≤ –∫–∞–Ω–∞–ª–µ ${newMessage.channelId}`);
                    return;
                }
            }

            if (newMessage.content) {
                const newChunks = LogsListener.splitMessage(newMessage.content);
                if (newChunks.length === 1) {
                    embed.addFields({ name: "–ù–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ", value: newChunks[0] });
                    await logChannel.send({ embeds: [embed] });
                } else {
                    embed.addFields({ name: "–ù–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (—á–∞—Å—Ç—å 1)", value: newChunks[0] });
                    await logChannel.send({ embeds: [embed] });

                    for (let i = 1; i < newChunks.length; i++) {
                        const followUp = createContentPartEmbed(
                            `–ù–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ (—á–∞—Å—Ç—å ${i + 1})`,
                            newChunks[i]
                        );
                        await logChannel.send({ embeds: [followUp] });
                    }
                }
            } else {
                await logChannel.send({ embeds: [embed] });
            }

            logger.info(`–ó–∞–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–æ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${newMessage.author?.tag} –≤ –∫–∞–Ω–∞–ª–µ ${newMessage.channelId}`);
        } catch (error) {
            logger.error("–û—à–∏–±–∫–∞ –≤ LogsListener (onMessageUpdate):", error);
        }
    }

    /**
     * –î–µ–ª–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏ —Å —É—á–µ—Ç–æ–º –ª–∏–º–∏—Ç–∞ —Å–∏–º–≤–æ–ª–æ–≤ Discord
     * @param text –¢–µ–∫—Å—Ç –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
     * @returns –ú–∞—Å—Å–∏–≤ —á–∞—Å—Ç–µ–π —Å–æ–æ–±—â–µ–Ω–∏—è
     */
    private static splitMessage(text: string): string[] {
        if (text.length <= MESSAGE_CHAR_LIMIT) {
            return [text];
        }
        const chunks: string[] = [];
        let current = "";
        for (const line of text.split("\n")) {
            if (current.length + line.length + 1 > MESSAGE_CHAR_LIMIT) {
                if (line.length > MESSAGE_CHAR_LIMIT) {
                    if (current) chunks.push(current);
                    current = "";
                    let pos = 0;
                    while (pos < line.length) {
                        chunks.push(line.slice(pos, pos + MESSAGE_CHAR_LIMIT));
                        pos += MESSAGE_CHAR_LIMIT;
                    }
                } else {
                    chunks.push(current);
                    current = line;
                }
            } else {
                current += (current ? "\n" : "") + line;
            }
        }
        if (current) chunks.push(current);
        return chunks;
    }
}

# ./src/handlers/InteractionHandler.ts
import { Discord, On } from "discordx";
import { Interaction, Events } from "discord.js";
import { RoleSelector } from "../events/RoleSelectorListener.js";
import logger from "../services/logger.js";

@Discord()
export class InteractionHandler {
    private roleSelector = new RoleSelector();
    
    @On({ event: Events.InteractionCreate })
    async onInteraction(interaction: Interaction): Promise<void> {
        try {
            if (interaction.isStringSelectMenu() && interaction.customId === 'select-role') {
                await this.roleSelector.handleRoleSelection(interaction).catch(error => {
                    logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏: ${error}`);
                });
            }
        } catch (error) {
            logger.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è: ${error}`);
        }
    }
}

# ./src/services/initDatabase.ts
import { AppDataSource } from "./database.js";
import { Config } from "../entities/Config.js";
import { GiftStats } from "../entities/GiftStats.js";
import { User } from "../entities/User.js";
import logger from "./logger.js";

export async function seedDefaultConfigs() {
    try {
        if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
            AppDataSource.entityMetadatas.forEach(metadata => {
                console.log(`Loaded entity: ${metadata.name}`);
            });
        }

        const configRepository = AppDataSource.getRepository(Config);
        const count = await configRepository.count();

        if (count === 0) {
            const defaultConfigs = [
                { key: "high_mod_level", value: "372452900531601408" },
                { key: "high_mod_level", value: "345630388460191756" },
                { key: "high_mod_level", value: "1352322947129413654" },
                { key: "high_mod_level", value: "1352385524446527609" },
                { key: "high_mod_level", value: "1363105989527601262" },
                { key: "user_commands_channel", value: "1206693103612858398" },
                { key: "gallery_chat", value: "1206715540308107266" },
                { key: "log_chat", value: "838735119870328852"}
            ];

            await configRepository.save(defaultConfigs);
            logger.info("Default configs inserted:", defaultConfigs);
        } else {
            logger.info("Configs already exist. Seed skipped.");
        }

        await initializeGiftStats();
    } catch (error) {
        logger.error("–û—à–∏–±–∫–∞ —Å–∏–¥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–µ—Ñ–æ–ª—Ç–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤:", error);
    }
}

/**
 * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ç–∞–±–ª–∏—Ü—É GiftStats –¥–ª—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 */
async function initializeGiftStats() {
    try {
        const userRepository = AppDataSource.getRepository(User);
        const giftStatsRepository = AppDataSource.getRepository(GiftStats);
        
        const giftStatsCount = await giftStatsRepository.count();
        
        if (giftStatsCount > 0) {
            logger.info("–¢–∞–±–ª–∏—Ü–∞ GiftStats —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø–∏—Å–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é");
            return;
        }
        
        const users = await userRepository.find();
        logger.info(`–ù–∞–π–¥–µ–Ω–æ ${users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ GiftStats`);
        
        if (users.length === 0) {
            logger.info("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ GiftStats");
            return;
        }
        
        const giftStatsBatch = users.map(user => ({
            discordId: user.discordId,
            userId: user.id,
            user: user,
            trackedVoiceMinutes: user.voiceMinutes,
            claimedGiftsFromVoice: 0,
            totalGiftsClaimed: 0,
            lastDailyGiftClaim: null
        }));
        
        await giftStatsRepository.save(giftStatsBatch);
        logger.info(`–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ ${giftStatsBatch.length} –∑–∞–ø–∏—Å–µ–π –≤ —Ç–∞–±–ª–∏—Ü–µ GiftStats`);
    } catch (error) {
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã GiftStats:", error);
    }
}

# ./src/services/logger.ts
import { createLogger, format, transports } from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import "dotenv/config";
// import axios from "axios";

const logFormat = format.combine(
  format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  format.errors({ stack: true }),
  format.splat(),
  format.json()
);

const logger = createLogger({
  level: "info",
  format: logFormat,
  defaultMeta: { service: "MarmokBot" },
  transports: [
    new transports.Console({
      format: format.combine(format.colorize(), format.simple())
    }),

    new DailyRotateFile({
      dirname: "logs/info",
      filename: "info-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      level: "info",
      maxFiles: "7d",
      zippedArchive: true
    }),

    new DailyRotateFile({
      dirname: "logs/warn",
      filename: "warn-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      level: "warn",
      maxFiles: "7d",
      zippedArchive: true
    }),

    new DailyRotateFile({
      dirname: "logs/error",
      filename: "error-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      level: "error",
      maxFiles: "7d",
      zippedArchive: true
    })
  ]
});

// –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤ –≤ Discord –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö
// const criticalWebhook = process.env.CRITICAL_WEBHOOK_URL;
// logger.on("data", (log) => {
//   if (log.level === "error" || log.level === "warn") {
//     if (criticalWebhook) {
//       // –í–∫–ª—é—á–∏—Ç—å axios –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
//       axios.post(criticalWebhook, {
//         content: `üö® **[${log.level.toUpperCase()}]** ${log.message}`,
//         embeds: [
//           {
//             description: "```json\n" + JSON.stringify(log, null, 2) + "\n```",
//             color: log.level === "error" ? 0xff0000 : 0xffa500
//           }
//         ]
//       }).catch((err) => {
//         console.error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–ª–µ—Ä—Ç–∞ –≤ Discord:", err);
//       });
//     }
//   }
// });

export default logger;


# ./src/services/database.ts
import { DataSource } from 'typeorm';
import { config } from 'dotenv';
import { User } from '../entities/User.js'; 
import { Exp } from '../entities/Exp.js';
import { Currency } from '../entities/Currency.js';
import { Config } from '../entities/Config.js';
import { CommandCooldown } from "../entities/CommandCooldown.js";
import { GiftStats } from '../entities/GiftStats.js';

config();

export const AppDataSource = new DataSource({
  type: 'mysql',
  host: process.env.DB_HOST || 'localhost',
  port: Number(process.env.DB_PORT) || 3306,
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  entities: [User, Exp, Currency, Config, CommandCooldown, GiftStats],
  synchronize: true,
  logging: ['error'],
  charset: 'utf8mb4',
  migrations: [],
  subscribers: [],
});


# ./src/services/giftSyncService.ts
import { AppDataSource } from "./database.js";
import { User } from "../entities/User.js";
import { GiftStats } from "../entities/GiftStats.js";
import logger from "./logger.js";

export class GiftSyncService {
  private static instance: GiftSyncService;
  private syncIntervalId: NodeJS.Timeout | null = null;
  private readonly SYNC_INTERVAL_MS = 30 * 60 * 1000; 

  private constructor() {
    this.initialize();
  }


  public static getInstance(): GiftSyncService {
    if (!GiftSyncService.instance) {
      GiftSyncService.instance = new GiftSyncService();
    }
    return GiftSyncService.instance;
  }

  private initialize(): void {
    logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è GiftSyncService");
    this.startSyncInterval();
  }


  private startSyncInterval(): void {
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
    }

    this.syncIntervalId = setInterval(() => {
      this.syncVoiceTimeWithGiftStats().catch(error => {
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ:", error);
      });
    }, this.SYNC_INTERVAL_MS);

    logger.info(`GiftSyncService: –∑–∞–ø—É—â–µ–Ω–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º ${this.SYNC_INTERVAL_MS / 60000} –º–∏–Ω—É—Ç`);
  }


  public stopSyncInterval(): void {
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
      logger.info("GiftSyncService: –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞");
    }
  }

  public async syncVoiceTimeWithGiftStats(): Promise<void> {
    try {
      logger.info("–ù–∞—á–∞–ª–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ —Å —Ç–∞–±–ª–∏—Ü–µ–π GiftStats");
      
      const userRepository = AppDataSource.getRepository(User);
      const giftStatsRepository = AppDataSource.getRepository(GiftStats);
      
      const allUsers = await userRepository.find();
      logger.info(`–ù–∞–π–¥–µ–Ω–æ ${allUsers.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏`);
      
      let syncCount = 0;
      let createdCount = 0;
      
      for (const user of allUsers) {
        let giftStats = await giftStatsRepository.findOne({
          where: { discordId: user.discordId }
        });
        
        if (!giftStats) {
          giftStats = giftStatsRepository.create({
            discordId: user.discordId,
            userId: user.id,
            user: user,
            trackedVoiceMinutes: user.voiceMinutes,
            claimedGiftsFromVoice: 0,
          });
          
          await giftStatsRepository.save(giftStats);
          createdCount++;
        } else {
          const currentVoiceMinutes = user.voiceMinutes;
          const trackedVoiceMinutes = giftStats.trackedVoiceMinutes;
          
          if (currentVoiceMinutes > trackedVoiceMinutes) {
            giftStats.trackedVoiceMinutes = currentVoiceMinutes;
            await giftStatsRepository.save(giftStats);
            syncCount++;
          }
        }
      }
      
      logger.info(`–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –û–±–Ω–æ–≤–ª–µ–Ω–æ: ${syncCount}, –°–æ–∑–¥–∞–Ω–æ: ${createdCount}`);
    } catch (error) {
      logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ:", error);
      throw error;
    }
  }
  
  public async forceSyncAll(): Promise<{syncCount: number, createdCount: number}> {
    try {
      logger.info("–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏");
      
      const userRepository = AppDataSource.getRepository(User);
      const giftStatsRepository = AppDataSource.getRepository(GiftStats);
      
      const allUsers = await userRepository.find();
      logger.info(`–ù–∞–π–¥–µ–Ω–æ ${allUsers.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏`);
      
      let syncCount = 0;
      let createdCount = 0;
      
      for (const user of allUsers) {
        let giftStats = await giftStatsRepository.findOne({
          where: { discordId: user.discordId }
        });
        
        if (!giftStats) {
          giftStats = giftStatsRepository.create({
            discordId: user.discordId,
            userId: user.id,
            user: user,
            trackedVoiceMinutes: user.voiceMinutes,
            claimedGiftsFromVoice: 0
          });
          
          await giftStatsRepository.save(giftStats);
          createdCount++;
        } else {
          giftStats.trackedVoiceMinutes = user.voiceMinutes;
          await giftStatsRepository.save(giftStats);
          syncCount++;
        }
      }
      
      logger.info(`–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –û–±–Ω–æ–≤–ª–µ–Ω–æ: ${syncCount}, –°–æ–∑–¥–∞–Ω–æ: ${createdCount}`);
      return { syncCount, createdCount };
    } catch (error) {
      logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:", error);
      throw error;
    }
  }
}

export const giftSyncService = GiftSyncService.getInstance();

# ./src/entities/Exp.ts
import { Entity, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn } from "typeorm";
import type { Relation } from "typeorm";
import type { User } from "./User.js";

@Entity()
export class Exp {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({
    type: "bigint",
    default: () => "0",
    unsigned: true,
    transformer: {
      to: (value: bigint) => value.toString(),
      from: (value: string | null) => BigInt(value || '0'),
    },
  })
  exp!: bigint;

  @Column({
    type: "int",
    unsigned: true,
  })
  level!: number;

  @Column({
    type: "timestamp",
    default: () => "CURRENT_TIMESTAMP",
  })
  createdAt!: Date;

  @OneToOne("User", "exp", { onDelete: "CASCADE" })
  @JoinColumn({ name: "user_id" })
  user!: Relation<User>;
}

# ./src/entities/Currency.ts
import { Column, Entity, PrimaryGeneratedColumn, OneToOne, JoinColumn, Relation } from "typeorm";
import type { User } from "./User.js";


@Entity()
export class Currency {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({
        type: "bigint",
        default: () => "0",
        unsigned: true,
        transformer: {
          to: (value: bigint) => value.toString(),
          from: (value: string | null) => BigInt(value || '0'),
        },
      })
      currencyCount!: bigint;

    @Column({
        type: "timestamp",
        default: () => "CURRENT_TIMESTAMP",
    })
    createdAt!: Date;

    @OneToOne("User", "currency", { onDelete: "CASCADE" })  
    @JoinColumn({ name: "user_id" })
    user!: Relation<User>;
}


# ./src/entities/RoleHistory.ts
import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, JoinColumn, CreateDateColumn } from "typeorm";
import type { Relation } from "typeorm";
import { User } from "./User.js";
import { CustomRole } from "./CustomRole.js";

@Entity()
export class RoleHistory {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  roleId!: number;

  @ManyToOne(() => CustomRole, role => role.history, { onDelete: "CASCADE" })
  @JoinColumn({ name: "roleId" })
  role!: Relation<CustomRole>;

  @Column({ length: 50 })
  actionType!: string;  
  
  @Column({ nullable: true })
  fromUserId!: number | null;

  @ManyToOne(() => User, { nullable: true })
  @JoinColumn({ name: "fromUserId" })
  fromUser!: Relation<User> | null;

  @Column({ nullable: true })
  toUserId!: number | null;

  @ManyToOne(() => User, { nullable: true })
  @JoinColumn({ name: "toUserId" })
  toUser!: Relation<User> | null;

  @CreateDateColumn()
  actionDate!: Date;

  @Column({ type: "text", nullable: true })
  details!: string | null;
}

# ./src/entities/CustomRole.ts
import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, OneToMany, JoinColumn, Index, CreateDateColumn } from "typeorm";
import type { Relation } from "typeorm";
import { User } from "./User.js";
import { RoleShare } from "./RoleShare.js";
import { RoleHistory } from "./RoleHistory.js";

@Entity()
export class CustomRole {
  @PrimaryGeneratedColumn()
  id!: number;

  @Index({ unique: true })
  @Column({ length: 100 })
  name!: string;

  @Column({ type: "text", nullable: true })
  description!: string;

  @Column()
  creatorId!: number;

  @ManyToOne(() => User)
  @JoinColumn({ name: "creatorId" })
  creator!: Relation<User>;

  @Column()
  ownerId!: number;

  @ManyToOne(() => User)
  @JoinColumn({ name: "ownerId" })
  owner!: Relation<User>;

  @CreateDateColumn()
  creationDate!: Date;

  @Column({ type: "timestamp", nullable: true })
  expirationDate!: Date | null;

  @Column({ default: true })
  isActive!: boolean;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  lastPaymentDate!: Date;

  @OneToMany(() => RoleShare, roleShare => roleShare.role)
  shares!: Relation<RoleShare[]>;

  @OneToMany(() => RoleHistory, roleHistory => roleHistory.role)
  history!: Relation<RoleHistory[]>;
}

# ./src/entities/CommandCooldown.ts
import { Entity, Column, PrimaryColumn } from "typeorm";

@Entity()
export class CommandCooldown {
    @PrimaryColumn()
    userId!: string;

    @PrimaryColumn()
    commandName!: string;

    @Column()
    lastUsed!: Date;
}

# ./src/entities/Config.ts
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class Config {
    @PrimaryGeneratedColumn()
    id!: number;

    @Column({
        type: "varchar",
        length: 255
    })
    key!: string;

    @Column({
        type: "varchar",
        unique: true,
        length: 255
    })
    value!: string;

    @Column({
        type: "timestamp",
        default: () => "CURRENT_TIMESTAMP",
    })
    createdAt!: Date;
}


# ./src/entities/RoleShare.ts
import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, JoinColumn, CreateDateColumn, Index } from "typeorm";
import type { Relation } from "typeorm";
import { User } from "./User.js";
import { CustomRole } from "./CustomRole.js";

@Entity()
export class RoleShare {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  roleId!: number;

  @ManyToOne(() => CustomRole, role => role.shares, { onDelete: "CASCADE" })
  @JoinColumn({ name: "roleId" })
  role!: Relation<CustomRole>;

  @Column()
  userId!: number;

  @ManyToOne(() => User)
  @JoinColumn({ name: "userId" })
  user!: Relation<User>;

  @CreateDateColumn()
  grantedDate!: Date;

  @Index("idx_unique_role_user", ["roleId", "userId"], { unique: true })
  uniqueRoleUser!: any; 
}

# ./src/entities/GiftStats.ts
import { Entity, PrimaryGeneratedColumn, Column, JoinColumn, ManyToOne, BeforeInsert, BeforeUpdate } from "typeorm";
import { User } from "./User.js";

@Entity()
export class GiftStats {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ unique: true })
  discordId!: string;

  @Column()
  userId!: number;

  @ManyToOne(() => User, user => user.giftStats)
  @JoinColumn({ name: 'userId' })
  user!: User;

  @Column('bigint', { 
    transformer: {
      from: (value: string | null) => value === null ? BigInt(0) : BigInt(value),
      to: (value: bigint) => String(value)
    },
    default: "0"  
  })
  trackedVoiceMinutes!: bigint;

  @Column({ default: 0 })
  claimedGiftsFromVoice!: number;

  @Column({ default: 0 })
  totalGiftsClaimed!: number;

  @Column({ default: 0 })
  availableGifts!: number;

  @Column({ nullable: true, type: 'datetime' })
  lastDailyGiftClaim!: Date | null;

  @BeforeInsert()
  @BeforeUpdate()
  ensureValidValues() {
    if (this.trackedVoiceMinutes === null || this.trackedVoiceMinutes === undefined) {
      this.trackedVoiceMinutes = BigInt(0);
    }
  }
}

# ./src/entities/User.ts
import { Entity, Column, Index, PrimaryGeneratedColumn, OneToOne } from "typeorm";
import type { Relation } from "typeorm";
import type { Exp } from "./Exp.js";
import { Currency } from "./Currency.js";
import { GiftStats } from "./GiftStats.js";

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id!: number;

  @Index({ unique: true })
  @Column()
  discordId!: string;

  @Column({
    type: "bigint",
    default: () => "0",
    unsigned: true,
    transformer: {
      to: (value: bigint) => value.toString(),
      from: (value: string | null) => BigInt(value || '0'), 
    },
  })
  messageCount!: bigint;

  @Column({
    type: "bigint",
    default: () => "0",
    unsigned: true,
    transformer: {
      to: (value: bigint) => value.toString(),
      from: (value: string | null) => BigInt(value || '0'),
    },
  })
  voiceMinutes!: bigint;

  @Column({
    type: "timestamp",
    default: () => "CURRENT_TIMESTAMP",
  })
  createdAt!: Date;

  @OneToOne("Exp", "user")
  exp!: Relation<Exp>;

  @OneToOne("Currency","user")
  currency!: Relation<Currency>;

  @OneToOne("GiftStats", "user")
  giftStats!: Relation<GiftStats>;
}

